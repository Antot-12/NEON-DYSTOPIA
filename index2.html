<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Space Shooter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            overflow: hidden;
            color: #00ffff;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(45deg, #0a0a0a, #1a0a1a, #0a1a0a);
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #001122 0%, #000000 70%);
            cursor: crosshair;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            font-size: 15px;
            background: rgba(0, 0, 0, 0.92);
            padding: 28px;
            border-radius: 18px;
            border: 4px solid #00ffff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6), inset 0 0 25px rgba(0, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            font-weight: 600;
        }
        
        #health {
            color: #ff0080;
            text-shadow: 0 0 10px #ff0080;
        }
        
        #ammo {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        #weaponInfo {
            color: #ff8800;
            text-shadow: 0 0 10px #ff8800;
        }
        
        #credits {
            color: #00ff80;
            text-shadow: 0 0 10px #00ff80;
        }
        
        #healthBar {
            width: 200px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0080, #ff8800);
            transition: width 0.3s;
        }
        
        #expBar {
            width: 200px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        #expFill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0080ff);
            transition: width 0.3s;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 160px;
            height: 160px;
            background: rgba(0, 20, 40, 0.95);
            border: 4px solid #00ffff;
            border-radius: 18px;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6), inset 0 0 25px rgba(0, 255, 255, 0.15);
            backdrop-filter: blur(15px);
        }
        
        #abilities {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.92);
            padding: 18px;
            border-radius: 18px;
            border: 4px solid #00ffff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6), inset 0 0 25px rgba(0, 255, 255, 0.15);
            backdrop-filter: blur(15px);
        }
        
        .ability {
            display: inline-block;
            width: 75px;
            height: 75px;
            margin: 12px;
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.15));
            border: 4px solid #00ffff;
            border-radius: 20px;
            text-align: center;
            line-height: 67px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            font-size: 30px;
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.15);
        }
        
        .ability:hover {
            background: linear-gradient(145deg, rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0.4));
            transform: scale(1.2) translateY(-4px);
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.7), inset 0 0 30px rgba(0, 255, 255, 0.25);
            border-color: #44ffff;
        }
        
        .ability.cooldown {
            background: linear-gradient(145deg, rgba(255, 0, 0, 0.4), rgba(255, 0, 0, 0.2));
            border-color: #ff4444;
            box-shadow: 0 6px 20px rgba(255, 0, 0, 0.3), inset 0 0 15px rgba(255, 0, 0, 0.1);
            opacity: 0.7;
        }
        
        .ability .cooldown-text {
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        #achievements {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ffff;
            border-radius: 18px;
            padding: 25px;
            max-width: 450px;
            max-height: 350px;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(0, 255, 255, 0.6), inset 0 0 25px rgba(0, 255, 255, 0.15);
            backdrop-filter: blur(15px);
        }
        
        #achievements h4 {
            margin: 0 0 20px 0;
            color: #00ffff;
            text-align: center;
            font-size: 18px;
            text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff;
            border-bottom: 3px solid #00ffff;
            padding-bottom: 12px;
            font-weight: 800;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        #achievementList {
            max-height: 260px;
            overflow-y: auto;
            padding-right: 15px;
            scrollbar-width: thin;
            scrollbar-color: #00ffff rgba(0, 0, 0, 0.3);
        }
        
        #achievementList::-webkit-scrollbar {
            width: 14px;
        }
        
        #achievementList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 7px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.1);
        }
        
        #achievementList::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #00ffff, #ff0080, #00ffff);
            border-radius: 7px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), inset 0 0 5px rgba(255, 255, 255, 0.2);
        }
        
        #achievementList::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #44ffff, #ff4499, #44ffff);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.9), inset 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        #achievementList::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.5);
        }
        
        .achievement {
            padding: 16px 20px;
            margin: 10px 0;
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.25), rgba(0, 255, 255, 0.2));
            border: 3px solid rgba(255, 255, 0, 0.5);
            border-radius: 12px;
            font-size: 13px;
            animation: achievementPop 0.8s ease-out;
            position: relative;
            overflow: hidden;
            box-shadow: 0 6px 20px rgba(255, 255, 0, 0.4), inset 0 0 15px rgba(255, 255, 0, 0.15);
            transition: all 0.4s ease;
            cursor: pointer;
        }
        
        .achievement:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 12px 35px rgba(255, 255, 0, 0.6), inset 0 0 25px rgba(255, 255, 0, 0.3);
            border-color: rgba(255, 255, 0, 0.8);
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.35), rgba(0, 255, 255, 0.25));
        }
        
        .achievement::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.25), transparent);
            animation: shimmer 4s infinite;
        }
        
        .achievement::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 8px;
            pointer-events: none;
        }
        
        .achievement strong {
            color: #ffff00;
            text-shadow: 0 0 12px #ffff00, 0 0 20px #ffff00;
            font-weight: 800;
            font-size: 14px;
        }
        
        @keyframes achievementPop {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(-90deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        /* Smooth scrolling performance */
        #achievementList, #allAchievements {
            scroll-behavior: smooth;
            overscroll-behavior: contain;
        }
        
        /* Enhanced achievement animation */
        @keyframes achievementGlow {
            0% { box-shadow: 0 6px 20px rgba(255, 255, 0, 0.4), inset 0 0 15px rgba(255, 255, 0, 0.15); }
            50% { box-shadow: 0 8px 30px rgba(255, 255, 0, 0.6), inset 0 0 25px rgba(255, 255, 0, 0.25); }
            100% { box-shadow: 0 6px 20px rgba(255, 255, 0, 0.4), inset 0 0 15px rgba(255, 255, 0, 0.15); }
        }
        
        .achievement {
            animation: achievementPop 0.8s ease-out, achievementGlow 3s ease-in-out infinite;
        }
        
        #weaponWheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 220px;
            height: 220px;
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #00ffff;
            border-radius: 50%;
            display: none;
            z-index: 300;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .weapon-slot {
            position: absolute;
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.1));
            border: 3px solid #00ffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }
        
        .weapon-slot:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0.3));
            transform: scale(1.3);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.6);
            border-color: #44ffff;
        }
        
        .glitch {
            animation: glitch 0.3s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000011, #110022, #001122);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        
        #title {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 900;
            color: #ff0080;
            text-shadow: 0 0 20px #ff0080, 0 0 40px #ff0080;
            margin-bottom: 1rem;
            animation: pulse 2s infinite;
            text-align: center;
        }
        
        .subtitle {
            font-size: clamp(1rem, 2vw, 1.2rem);
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 3rem;
            text-align: center;
            font-weight: 300;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Button System */
        .btn-primary, .btn-secondary, .btn-menu {
            font-family: 'Orbitron', monospace;
            border: none;
            cursor: pointer;
            font-weight: 600;
            border-radius: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            text-decoration: none;
            outline: none;
            user-select: none;
            box-sizing: border-box;
        }
        
        .btn-primary {
            padding: 20px 40px;
            font-size: 1.4rem;
            background: linear-gradient(135deg, #00ffff, #ff0080);
            color: #000;
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.3);
            min-width: 200px;
            font-weight: 700;
        }
        
        .btn-primary:hover, .btn-primary:focus {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(0, 255, 255, 0.5);
            background: linear-gradient(135deg, #44ffff, #ff4499);
        }
        
        .btn-secondary {
            padding: 15px 30px;
            font-size: 1.1rem;
            background: rgba(0, 255, 255, 0.1);
            color: #00ffff;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
            min-width: 150px;
        }
        
        .btn-secondary:hover, .btn-secondary:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4);
        }
        
        .btn-menu {
            padding: 12px 20px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            justify-content: flex-start;
            text-align: left;
            font-weight: 500;
        }
        
        .btn-menu:hover, .btn-menu:focus {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
            color: #00ffff;
        }
        
        .btn-icon {
            font-size: 1.2em;
            filter: drop-shadow(0 0 5px currentColor);
        }
        
        .btn-text {
            font-weight: inherit;
        }
        
        /* Layout Components */
        .primary-buttons {
            display: flex;
            gap: 20px;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .secondary-menu {
            position: relative;
            margin-bottom: 2rem;
        }
        
        .menu-panel {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px;
            min-width: 250px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .menu-panel.open {
            display: block;
            animation: menuSlideIn 0.3s ease;
        }
        
        @keyframes menuSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        .quick-stats {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding: 15px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            min-width: 80px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #888;
            text-transform: uppercase;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: #00ffff;
            font-weight: 700;
            text-shadow: 0 0 8px #00ffff;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .primary-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary {
                width: 100%;
                max-width: 300px;
            }
            
            .quick-stats {
                flex-direction: column;
                gap: 15px;
            }
            
            .stat-item {
                flex-direction: row;
                justify-content: space-between;
                text-align: left;
            }
        }
        
        /* Accessibility Improvements */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* High contrast mode */
        @media (prefers-contrast: high) {
            .btn-primary {
                background: #ffffff;
                color: #000000;
                border: 2px solid #000000;
            }
            
            .btn-secondary {
                background: #000000;
                color: #ffffff;
                border: 2px solid #ffffff;
            }
            
            .stat-value {
                color: #ffffff;
                text-shadow: none;
            }
        }
        
        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        #gameOver, #shop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }
        
        .game-over-content {
            background: linear-gradient(135deg, rgba(20, 0, 40, 0.95), rgba(40, 0, 20, 0.9));
            border: 3px solid #ff0080;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            margin: 50px auto;
            box-shadow: 0 20px 60px rgba(255, 0, 128, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0080;
            text-shadow: 0 0 30px #ff0080;
            margin-bottom: 30px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: glitch 0.3s infinite;
        }
        
        .game-over-stats {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #00ffff;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .stat-value {
            color: #ffff00;
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .game-over-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .game-over-buttons .btn-primary,
        .game-over-buttons .btn-secondary {
            width: 100%;
            justify-content: center;
            font-size: 1.1rem;
            padding: 18px 30px;
        }
        
        @media (max-width: 768px) {
            .game-over-content {
                padding: 20px;
                margin: 20px auto;
            }
            
            .game-over-title {
                font-size: 2rem;
            }
            
            .stat-row {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
        }
        
        .game-over-content {
            background: linear-gradient(135deg, rgba(20, 0, 40, 0.95), rgba(40, 0, 20, 0.9));
            border: 3px solid #ff0080;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            margin: 50px auto;
            box-shadow: 0 20px 60px rgba(255, 0, 128, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0080;
            text-shadow: 0 0 30px #ff0080;
            margin-bottom: 30px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: glitch 0.3s infinite;
        }
        
        .game-over-stats {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #00ffff;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .stat-value {
            color: #ffff00;
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .game-over-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .game-over-buttons .btn-primary,
        .game-over-buttons .btn-secondary {
            width: 100%;
            justify-content: center;
            font-size: 1.1rem;
            padding: 18px 30px;
        }
        
        @media (max-width: 768px) {
            .game-over-content {
                padding: 20px;
                margin: 20px auto;
            }
            
            .game-over-title {
                font-size: 2rem;
            }
            
            .stat-row {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
        }
        
        .game-over-content {
            background: linear-gradient(135deg, rgba(20, 0, 40, 0.95), rgba(40, 0, 20, 0.9));
            border: 3px solid #ff0080;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            margin: 50px auto;
            box-shadow: 0 20px 60px rgba(255, 0, 128, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0080;
            text-shadow: 0 0 30px #ff0080;
            margin-bottom: 30px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: glitch 0.3s infinite;
        }
        
        .game-over-stats {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #00ffff;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .stat-value {
            color: #ffff00;
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .game-over-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .game-over-buttons .btn-primary,
        .game-over-buttons .btn-secondary {
            width: 100%;
            justify-content: center;
            font-size: 1.1rem;
            padding: 18px 30px;
        }
        
        @media (max-width: 768px) {
            .game-over-content {
                padding: 20px;
                margin: 20px auto;
            }
            
            .game-over-title {
                font-size: 2rem;
            }
            
            .stat-row {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
        }
        
        .game-over-content {
            background: linear-gradient(135deg, rgba(20, 0, 40, 0.95), rgba(40, 0, 20, 0.9));
            border: 3px solid #ff0080;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            margin: 50px auto;
            box-shadow: 0 20px 60px rgba(255, 0, 128, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0080;
            text-shadow: 0 0 30px #ff0080;
            margin-bottom: 30px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: glitch 0.3s infinite;
        }
        
        .game-over-stats {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #00ffff;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .stat-value {
            color: #ffff00;
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .game-over-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .game-over-buttons .btn-primary,
        .game-over-buttons .btn-secondary {
            width: 100%;
            justify-content: center;
            font-size: 1.1rem;
            padding: 18px 30px;
        }
        
        @media (max-width: 768px) {
            .game-over-content {
                padding: 20px;
                margin: 20px auto;
            }
            
            .game-over-title {
                font-size: 2rem;
            }
            
            .stat-row {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
        }
        
        .game-over-content {
            background: linear-gradient(135deg, rgba(20, 0, 40, 0.95), rgba(40, 0, 20, 0.9));
            border: 3px solid #ff0080;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            margin: 50px auto;
            box-shadow: 0 20px 60px rgba(255, 0, 128, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-over-title {
            font-size: 3rem;
            color: #ff0080;
            text-shadow: 0 0 30px #ff0080;
            margin-bottom: 30px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: glitch 0.3s infinite;
        }
        
        .game-over-stats {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #00ffff;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .stat-value {
            color: #ffff00;
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .game-over-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 30px;
        }
        
        .game-over-buttons .btn-primary,
        .game-over-buttons .btn-secondary {
            width: 100%;
            justify-content: center;
            font-size: 1.1rem;
            padding: 18px 30px;
        }
        
        @media (max-width: 768px) {
            .game-over-content {
                padding: 20px;
                margin: 20px auto;
            }
            
            .game-over-title {
                font-size: 2rem;
            }
            
            .stat-row {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
        }
        
        #achievementScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 20, 40, 0.9));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
        }
        
        #allAchievements {
            max-width: 1000px;
            max-height: 75vh;
            overflow-y: auto;
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
            gap: 25px;
            scrollbar-width: thin;
            scrollbar-color: #00ffff rgba(0, 0, 0, 0.3);
        }
        
        #allAchievements::-webkit-scrollbar {
            width: 16px;
        }
        
        #allAchievements::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.1);
        }
        
        #allAchievements::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #00ffff, #ff0080, #00ffff);
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.2);
        }
        
        #allAchievements::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #44ffff, #ff4499, #44ffff);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.9), inset 0 0 15px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        #allAchievements::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.5);
        }
        
        #allAchievements .shop-item {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 128, 0.15));
            border: 4px solid #00ffff;
            padding: 30px;
            margin: 0;
            border-radius: 18px;
            cursor: default;
            transition: all 0.4s ease;
            width: auto;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.15);
        }
        
        #allAchievements .shop-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
            animation: shimmer 4s infinite;
        }
        
        #allAchievements .shop-item:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 20px 50px rgba(0, 255, 255, 0.6), inset 0 0 30px rgba(0, 255, 255, 0.25);
            border-color: #44ffff;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(255, 0, 128, 0.2));
        }
        
        #allAchievements .shop-item h3 {
            margin: 0 0 12px 0;
            font-size: 20px;
            font-weight: 700;
        }
        
        #allAchievements .shop-item p {
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 8px;
        }
        
        #allAchievements .shop-item.unlocked {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.3), rgba(0, 255, 255, 0.2));
            border-color: #00ff00;
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.5), inset 0 0 20px rgba(0, 255, 0, 0.15);
        }
        
        #allAchievements .shop-item.unlocked:hover {
            box-shadow: 0 20px 50px rgba(0, 255, 0, 0.7), inset 0 0 30px rgba(0, 255, 0, 0.25);
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.4), rgba(0, 255, 255, 0.25));
        }
        
        #allAchievements .shop-item.unlocked::after {
            content: '✓';
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 32px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        .shop-item {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 128, 0.15));
            border: 4px solid #00ffff;
            padding: 25px;
            margin: 15px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s ease;
            width: 400px;
            position: relative;
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.15);
        }
        
        .shop-item:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.35), rgba(255, 0, 128, 0.2));
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.6), inset 0 0 25px rgba(0, 255, 255, 0.25);
            border-color: #44ffff;
        }
        
        .shop-item.unavailable {
            opacity: 0.6;
            cursor: not-allowed;
            background: linear-gradient(135deg, rgba(128, 128, 128, 0.1), rgba(64, 64, 64, 0.1));
            border-color: #666;
        }
        
        .neon-text {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        /* Modal System */
        .modal-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 20px;
            padding: 40px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            position: relative;
        }
        
        .modal-title {
            font-size: 2.5rem;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 700;
        }
        
        .modal-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        /* Settings System */
        .settings-tabs, .controls-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover, .tab-btn:focus {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
        }
        
        .tab-btn.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .settings-panel, .controls-panel {
            min-height: 300px;
        }
        
        .settings-section, .controls-section {
            display: none;
        }
        
        .settings-section.active, .controls-section.active {
            display: block;
        }
        
        .setting-group {
            margin-bottom: 25px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .setting-label:hover {
            color: #00ffff;
        }
        
        .setting-label[for] {
            margin-bottom: 8px;
        }
        
        /* Custom Checkbox */
        .checkmark {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        input[type="checkbox"] {
            display: none;
        }
        
        input[type="checkbox"]:checked + .checkmark {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
        }
        
        input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        /* Slider Styles */
        .slider {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .setting-select {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .setting-select:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            outline: none;
        }
        
        .setting-select option {
            background: #1a1a1a;
            color: #fff;
        }
        
        /* Controls Layout */
        .control-category {
            margin-bottom: 30px;
        }
        
        .control-category h3 {
            color: #00ffff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-shadow: 0 0 8px #00ffff;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .control-item:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .control-action {
            color: #fff;
            font-weight: 500;
        }
        
        .control-key {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 6px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', monospace;
            font-weight: 600;
            text-shadow: 0 0 5px #00ffff;
            min-width: 40px;
            text-align: center;
        }
        
        .gamepad-layout, .custom-controls {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .gamepad-layout p, .custom-controls p {
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* Keyboard Navigation */
        .btn-primary:focus-visible,
        .btn-secondary:focus-visible,
        .btn-menu:focus-visible,
        .tab-btn:focus-visible,
        .slider:focus-visible,
        .setting-select:focus-visible {
            outline: 3px solid #ffff00;
            outline-offset: 2px;
        }
        
        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            .modal-content {
                animation: none;
            }
            
            .menu-panel {
                animation: none;
            }
            
            * {
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                padding: 20px;
                margin: 20px;
            }
            
            .modal-title {
                font-size: 2rem;
            }
            
            .settings-tabs, .controls-tabs {
                flex-direction: column;
                align-items: center;
            }
            
            .tab-btn {
                width: 100%;
                max-width: 200px;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn-primary, .btn-secondary {
                width: 100%;
                max-width: 250px;
            }
        }
        
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 10px;
        }
        
        .tab {
            padding: 12px 25px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.1));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tab:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.2));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }
        
        .tab.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0.3));
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .shop-category {
            width: 100%;
            max-width: 1200px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff0080);
            transition: width 0.3s ease;
        }
        
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 10px;
        }
        
        .tab {
            padding: 12px 25px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.1));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tab:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.2));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }
        
        .tab.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0.3));
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .shop-category {
            width: 100%;
            max-width: 1200px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff0080);
            transition: width 0.3s ease;
        }
        
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            gap: 10px;
        }
        
        .tab {
            padding: 12px 25px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.1));
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tab:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4), rgba(0, 255, 255, 0.2));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }
        
        .tab.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.6), rgba(0, 255, 255, 0.3));
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        .shop-category {
            width: 100%;
            max-width: 1200px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff0080);
            transition: width 0.3s ease;
        }
        
        .notification {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.95), rgba(0, 200, 255, 0.9));
            color: #000;
            padding: 30px 40px;
            border-radius: 18px;
            font-weight: bold;
            z-index: 300;
            animation: notificationShow 3s forwards;
            box-shadow: 0 15px 50px rgba(0, 255, 255, 0.7), inset 0 0 25px rgba(255, 255, 255, 0.25);
            border: 3px solid rgba(255, 255, 255, 0.4);
            font-size: 18px;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        
        @keyframes notificationShow {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5); 
            }
            20% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1); 
            }
            25% { 
                transform: translate(-50%, -50%) scale(1); 
            }
            75% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.8); 
            }
        }
        
        #comboCounter {
            position: absolute;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 36px;
            color: #ffff00;
            text-shadow: 0 0 30px #ffff00;
            display: none;
            background: rgba(0, 0, 0, 0.92);
            padding: 25px 30px;
            border-radius: 18px;
            border: 4px solid #ffff00;
            box-shadow: 0 0 60px rgba(255, 255, 0, 0.6), inset 0 0 25px rgba(255, 255, 0, 0.15);
            text-align: center;
            animation: pulse 0.3s infinite alternate;
            backdrop-filter: blur(10px);
        }
        
        #comboCounter #comboValue {
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 35px #ffff00, 0 0 50px #ffff00;
            letter-spacing: 3px;
        }
        
        .screen-shake {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 250;
        }
        
        .warning {
            color: #ff4444;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 128, 0.15));
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.3);
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.5);
            border-color: #44ffff;
        }
        
        .stat-card h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .mission-item {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(255, 255, 0, 0.1));
            border: 2px solid rgba(255, 255, 0, 0.5);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            transition: all 0.3s ease;
        }
        
        .mission-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 255, 0, 0.3);
        }
        
        .mission-item h3 {
            color: #ffff00;
            margin-bottom: 10px;
            text-shadow: 0 0 8px #ffff00;
        }
        
        .research-node {
            background: linear-gradient(135deg, rgba(128, 0, 255, 0.2), rgba(0, 255, 128, 0.15));
            border: 2px solid #8800ff;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .research-node:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(136, 0, 255, 0.4);
        }
        
        .research-node.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 128, 0.15));
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.3);
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.5);
            border-color: #44ffff;
        }
        
        .stat-card h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .mission-item {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.15), rgba(255, 255, 0, 0.1));
            border: 2px solid rgba(255, 255, 0, 0.5);
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            transition: all 0.3s ease;
        }
        
        .mission-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 255, 0, 0.3);
        }
        
        .mission-item h3 {
            color: #ffff00;
            margin-bottom: 10px;
            text-shadow: 0 0 8px #ffff00;
        }
        
        .research-node {
            background: linear-gradient(135deg, rgba(128, 0, 255, 0.2), rgba(0, 255, 128, 0.15));
            border: 2px solid #8800ff;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .research-node:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(136, 0, 255, 0.4);
        }
        
        .research-node.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Level: <span id="level">1</span> | XP: <span id="experience">0</span>/<span id="nextLevel">100</span></div>
            <div id="expBar"><div id="expFill"></div></div>
            <div id="health">Health: <span id="healthValue">100</span>/<span id="maxHealthValue">100</span></div>
            <div id="healthBar"><div id="healthFill"></div></div>
            <div id="ammo">Ammo: <span id="ammoValue">30</span>/<span id="maxAmmoValue">30</span></div>
            <div id="weaponInfo">Weapon: <span id="weaponName">Blaster</span></div>
            <div id="credits">Credits: <span id="creditsValue">0</span></div>
            <div>Wave: <span id="wave">1</span> | Kills: <span id="kills">0</span></div>
            <div>Combo: <span id="combo">0</span>x</div>
        </div>
        
        <div id="comboCounter">
            <div>COMBO</div>
            <div id="comboValue">0</div>
        </div>
        
        <canvas id="minimap"></canvas>
        
        <div id="abilities">
            <div class="ability" id="shield" title="Energy Shield (Q)">
                🛡️
                <div class="cooldown-text"></div>
            </div>
            <div class="ability" id="dash" title="Cyber Dash (E)">
                ⚡
                <div class="cooldown-text"></div>
            </div>
            <div class="ability" id="bomb" title="EMP Bomb (F)">
                💥
                <div class="cooldown-text"></div>
            </div>
            <div class="ability" id="time" title="Bullet Time (T)">
                ⏰
                <div class="cooldown-text"></div>
            </div>
            <div class="ability" id="heal" title="Nano Heal (G)">
                ❤️
                <div class="cooldown-text"></div>
            </div>
        </div>
        
        <div id="achievements">
            <h4>Achievements</h4>
            <div id="achievementList"></div>
        </div>
        
        <div id="weaponWheel">
            <div class="weapon-slot" style="top: 10px; left: 80px;" data-weapon="blaster">1</div>
            <div class="weapon-slot" style="top: 50px; right: 10px;" data-weapon="rifle">2</div>
            <div class="weapon-slot" style="bottom: 50px; right: 10px;" data-weapon="shotgun">3</div>
            <div class="weapon-slot" style="bottom: 10px; left: 80px;" data-weapon="plasma">4</div>
            <div class="weapon-slot" style="bottom: 50px; left: 10px;" data-weapon="laser">5</div>
            <div class="weapon-slot" style="top: 50px; left: 10px;" data-weapon="rocket">6</div>
        </div>
        
        <div id="startScreen">
            <h1 id="title">NEON DYSTOPIA</h1>
            <p class="subtitle">Ultimate Cyberpunk Space Shooter</p>
            
            <!-- Primary Action Buttons -->
            <div class="primary-buttons">
                <button id="startBtn" class="btn-primary">
                    <span class="btn-icon">⚡</span>
                    <span class="btn-text">Jack In</span>
                </button>
                <button id="shopBtn" class="btn-primary">
                    <span class="btn-icon">🔧</span>
                    <span class="btn-text">Upgrade Matrix</span>
                </button>
            </div>
            
            <!-- Secondary Menu -->
            <div class="secondary-menu">
                <button id="menuToggle" class="btn-secondary">
                    <span class="btn-icon">☰</span>
                    <span class="btn-text">Menu</span>
                </button>
                <div id="menuPanel" class="menu-panel">
                    <button id="achievementsBtn" class="btn-menu">
                        <span class="btn-icon">🏆</span>
                        <span class="btn-text">Achievements</span>
                    </button>
                    <button onclick="showMissions()" class="btn-menu">
                        <span class="btn-icon">📋</span>
                        <span class="btn-text">Mission Control</span>
                    </button>
                    <button onclick="showStatistics()" class="btn-menu">
                        <span class="btn-icon">📊</span>
                        <span class="btn-text">Statistics</span>
                    </button>
                    <button onclick="showSettings()" class="btn-menu">
                        <span class="btn-icon">⚙️</span>
                        <span class="btn-text">Settings</span>
                    </button>
                    <button onclick="showControls()" class="btn-menu">
                        <span class="btn-icon">🎮</span>
                        <span class="btn-text">Controls</span>
                    </button>
                </div>
            </div>
            
            <!-- Quick Stats -->
            <div class="quick-stats">
                <div class="stat-item">
                    <span class="stat-label">Sessions</span>
                    <span class="stat-value" id="sessionCount">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Best Wave</span>
                    <span class="stat-value" id="bestWave">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Total Kills</span>
                    <span class="stat-value" id="totalKillsDisplay">0</span>
                </div>
            </div>
        </div>
        
        <div id="settingsScreen" class="modal-screen">
            <div class="modal-content">
                <h2 class="modal-title">Settings</h2>
                
                <div class="settings-tabs">
                    <button class="tab-btn active" onclick="switchSettingsTab('general')">General</button>
                    <button class="tab-btn" onclick="switchSettingsTab('accessibility')">Accessibility</button>
                    <button class="tab-btn" onclick="switchSettingsTab('audio')">Audio</button>
                    <button class="tab-btn" onclick="switchSettingsTab('graphics')">Graphics</button>
                </div>
                
                <div class="settings-panel">
                    <div id="generalSettings" class="settings-section active">
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="autoSaveToggle" checked>
                                <span class="checkmark"></span>
                                Auto-Save Progress
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="vibrationToggle" checked>
                                <span class="checkmark"></span>
                                Vibration (Gamepad)
                            </label>
                        </div>
                    </div>
                    
                    <div id="accessibilitySettings" class="settings-section">
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="highContrastToggle">
                                <span class="checkmark"></span>
                                High Contrast Mode
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="reducedMotionToggle">
                                <span class="checkmark"></span>
                                Reduce Motion
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="colorblindToggle">
                                <span class="checkmark"></span>
                                Colorblind Friendly
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label" for="fontSizeSlider">Font Size</label>
                            <input type="range" id="fontSizeSlider" min="80" max="150" value="100" class="slider">
                            <span id="fontSizeValue">100%</span>
                        </div>
                    </div>
                    
                    <div id="audioSettings" class="settings-section">
                        <div class="setting-group">
                            <label class="setting-label" for="volumeSlider">Master Volume</label>
                            <input type="range" id="volumeSlider" min="0" max="100" value="50" class="slider">
                            <span id="volumeValue">50%</span>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label" for="sfxVolumeSlider">Sound Effects</label>
                            <input type="range" id="sfxVolumeSlider" min="0" max="100" value="75" class="slider">
                            <span id="sfxVolumeValue">75%</span>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label" for="musicVolumeSlider">Music</label>
                            <input type="range" id="musicVolumeSlider" min="0" max="100" value="50" class="slider">
                            <span id="musicVolumeValue">50%</span>
                        </div>
                    </div>
                    
                    <div id="graphicsSettings" class="settings-section">
                        <div class="setting-group">
                            <label class="setting-label" for="qualitySelect">Graphics Quality</label>
                            <select id="qualitySelect" class="setting-select">
                                <option value="low">Low</option>
                                <option value="medium" selected>Medium</option>
                                <option value="high">High</option>
                                <option value="ultra">Ultra</option>
                            </select>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="particlesToggle" checked>
                                <span class="checkmark"></span>
                                Particle Effects
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="screenShakeToggle" checked>
                                <span class="checkmark"></span>
                                Screen Shake
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">
                                <input type="checkbox" id="bloomToggle" checked>
                                <span class="checkmark"></span>
                                Bloom Effects
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="modal-buttons">
                    <button onclick="resetSettings()" class="btn-secondary">Reset to Default</button>
                    <button onclick="closeSettings()" class="btn-primary">Close</button>
                </div>
            </div>
        </div>
        
        <div id="controlsScreen" class="modal-screen">
            <div class="modal-content">
                <h2 class="modal-title">Controls</h2>
                
                <div class="controls-tabs">
                    <button class="tab-btn active" onclick="switchControlsTab('keyboard')">Keyboard</button>
                    <button class="tab-btn" onclick="switchControlsTab('gamepad')">Gamepad</button>
                    <button class="tab-btn" onclick="switchControlsTab('custom')">Custom</button>
                </div>
                
                <div class="controls-panel">
                    <div id="keyboardControls" class="controls-section active">
                        <div class="control-category">
                            <h3>Movement</h3>
                            <div class="control-grid">
                                <div class="control-item">
                                    <span class="control-action">Move Forward</span>
                                    <span class="control-key">W</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Move Backward</span>
                                    <span class="control-key">S</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Move Left</span>
                                    <span class="control-key">A</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Move Right</span>
                                    <span class="control-key">D</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="control-category">
                            <h3>Combat</h3>
                            <div class="control-grid">
                                <div class="control-item">
                                    <span class="control-action">Aim & Shoot</span>
                                    <span class="control-key">Mouse</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Reload</span>
                                    <span class="control-key">R</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Switch Weapons</span>
                                    <span class="control-key">1-6</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Weapon Wheel</span>
                                    <span class="control-key">Tab</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="control-category">
                            <h3>Abilities</h3>
                            <div class="control-grid">
                                <div class="control-item">
                                    <span class="control-action">Energy Shield</span>
                                    <span class="control-key">Q</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Cyber Dash</span>
                                    <span class="control-key">E</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">EMP Bomb</span>
                                    <span class="control-key">F</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Bullet Time</span>
                                    <span class="control-key">T</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Nano Heal</span>
                                    <span class="control-key">G</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="control-category">
                            <h3>System</h3>
                            <div class="control-grid">
                                <div class="control-item">
                                    <span class="control-action">Shop</span>
                                    <span class="control-key">Space</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Pause</span>
                                    <span class="control-key">P</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Mute/Unmute</span>
                                    <span class="control-key">M</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-action">Main Menu</span>
                                    <span class="control-key">Esc</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="gamepadControls" class="controls-section">
                        <div class="gamepad-layout">
                            <p>Gamepad support coming soon!</p>
                            <p>Connect your controller and customize bindings in the Custom tab.</p>
                        </div>
                    </div>
                    
                    <div id="customControls" class="controls-section">
                        <div class="custom-controls">
                            <p>Custom key binding system coming soon!</p>
                            <p>Click on any control to rebind it to your preferred key.</p>
                        </div>
                    </div>
                </div>
                
                <div class="modal-buttons">
                    <button onclick="resetControls()" class="btn-secondary">Reset to Default</button>
                    <button onclick="closeControls()" class="btn-primary">Close</button>
                </div>
            </div>
        </div>
        
        <div id="shop">
            <h2 class="neon-text">UPGRADE MATRIX</h2>
            <div class="tab-container">
                <div class="tab active" onclick="switchShopTab('upgrades')">UPGRADES</div>
                <div class="tab" onclick="switchShopTab('weapons')">WEAPONS</div>
                <div class="tab" onclick="switchShopTab('equipment')">EQUIPMENT</div>
                <div class="tab" onclick="switchShopTab('consumables')">CONSUMABLES</div>
            </div>
            
            <div id="upgradesTab" class="shop-category">
                <h3>CORE UPGRADES</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">
                    <div class="shop-item" onclick="buyUpgrade('health')">
                        <h3>Health Boost</h3>
                        <p>+25 Max Health | Cost: <span id="healthCost">500</span> Credits</p>
                        <small>Level: <span id="healthLevel">0</span>/10</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="healthProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('damage')">
                        <h3>Damage Amplifier</h3>
                        <p>+50% Weapon Damage | Cost: <span id="damageCost">750</span> Credits</p>
                        <small>Level: <span id="damageLevel">0</span>/5</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="damageProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('speed')">
                        <h3>Neural Accelerator</h3>
                        <p>+30% Movement Speed | Cost: <span id="speedCost">600</span> Credits</p>
                        <small>Level: <span id="speedLevel">0</span>/5</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="speedProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('armor')">
                        <h3>Cyber Armor</h3>
                        <p>+10% Damage Reduction | Cost: <span id="armorCost">800</span> Credits</p>
                        <small>Level: <span id="armorLevel">0</span>/8</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="armorProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('criticalChance')">
                        <h3>Critical Strike</h3>
                        <p>+5% Critical Hit Chance | Cost: <span id="criticalChanceCost">900</span> Credits</p>
                        <small>Level: <span id="criticalChanceLevel">0</span>/10</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="criticalChanceProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('energyEfficiency')">
                        <h3>Energy Efficiency</h3>
                        <p>+20% Energy Regeneration | Cost: <span id="energyEfficiencyCost">700</span> Credits</p>
                        <small>Level: <span id="energyEfficiencyLevel">0</span>/5</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="energyEfficiencyProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('regen')">
                        <h3>Health Regeneration</h3>
                        <p>+2 Health per second | Cost: <span id="regenCost">1200</span> Credits</p>
                        <small>Level: <span id="regenLevel">0</span>/3</small>
                        <div class="progress-bar">
                            <div class="progress-fill" id="regenProgress" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="weaponsTab" class="shop-category" style="display: none;">
                <h3>WEAPON ARSENAL</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;" id="weaponShopItems">
                </div>
            </div>
            
            <div id="equipmentTab" class="shop-category" style="display: none;">
                <h3>EQUIPMENT & MODULES</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">
                    <div class="shop-item" onclick="buyUpgrade('shieldCapacity')">
                        <h3>Shield Generator</h3>
                        <p>+50 Shield Capacity | Cost: <span id="shieldCapacityCost">1200</span> Credits</p>
                        <small>Level: <span id="shieldCapacityLevel">0</span>/5</small>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('magneticRadius')">
                        <h3>Magnetic Collector</h3>
                        <p>Auto-collect nearby items | Cost: <span id="magneticRadiusCost">800</span> Credits</p>
                        <small>Level: <span id="magneticRadiusLevel">0</span>/3</small>
                    </div>
                    <div class="shop-item" onclick="buyUpgrade('luck')">
                        <h3>Quantum Luck Field</h3>
                        <p>+15% Better Drops | Cost: <span id="luckCost">1500</span> Credits</p>
                        <small>Level: <span id="luckLevel">0</span>/5</small>
                    </div>
                </div>
            </div>
            
            <div id="consumablesTab" class="shop-category" style="display: none;">
                <h3>CONSUMABLES & BOOSTERS</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">
                    <div class="shop-item" onclick="buyConsumable('healthPack')">
                        <h3>Health Pack</h3>
                        <p>Restore 75 Health | Cost: 100 Credits</p>
                        <small>Owned: <span id="healthPackCount">0</span></small>
                    </div>
                    <div class="shop-item" onclick="buyConsumable('energyBooster')">
                        <h3>Energy Booster</h3>
                        <p>+50% Energy Regen for 60s | Cost: 150 Credits</p>
                        <small>Owned: <span id="energyBoosterCount">0</span></small>
                    </div>
                    <div class="shop-item" onclick="buyConsumable('damageBooster')">
                        <h3>Damage Booster</h3>
                        <p>+100% Damage for 30s | Cost: 200 Credits</p>
                        <small>Owned: <span id="damageBoosterCount">0</span></small>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; display: flex; gap: 30px; justify-content: center; flex-wrap: wrap;">
                <button onclick="closeShop()" class="neon-text">DISCONNECT</button>
                <button onclick="showResearch()" class="neon-text">RESEARCH LAB</button>
                <button onclick="goToMainMenu()" class="neon-text">MAIN MENU</button>
            </div>
        </div>
        
        <div id="researchScreen">
            <h2 class="neon-text">RESEARCH LABORATORY</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; max-width: 1200px;" id="researchNodes">
            </div>
            <button onclick="closeResearch()" class="neon-text">BACK TO SHOP</button>
        </div>
        
        <div id="missionScreen">
            <h2 class="neon-text">MISSION CONTROL</h2>
            <div class="tab-container">
                <div class="tab active" onclick="switchMissionTab('active')">ACTIVE</div>
                <div class="tab" onclick="switchMissionTab('available')">AVAILABLE</div>
                <div class="tab" onclick="switchMissionTab('completed')">COMPLETED</div>
            </div>
            <div id="activeMissions" style="max-width: 800px;"></div>
            <div id="availableMissions" style="max-width: 800px; display: none;"></div>
            <div id="completedMissions" style="max-width: 800px; display: none;"></div>
            <button onclick="closeMissions()" class="neon-text">CLOSE</button>
        </div>
        
        <div id="statisticsScreen">
            <h2 class="neon-text">COMBAT STATISTICS</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; max-width: 1200px;" id="statsContainer">
            </div>
            <button onclick="closeStatistics()" class="neon-text">CLOSE</button>
        </div>
        
        <div id="achievementScreen">
            <h2 class="neon-text">ACHIEVEMENTS</h2>
            <div id="allAchievements"></div>
            <button onclick="closeAchievements()" class="neon-text">BACK</button>
        </div>
        
        <div id="pauseMenu">
            <h2 class="neon-text">SYSTEM PAUSED</h2>
            <button onclick="resumeGame()" class="neon-text">RESUME</button>
            <button onclick="showShop()" class="neon-text">UPGRADE MATRIX</button>
            <button onclick="restartGame()" class="neon-text">RESTART</button>
            <button onclick="goToMenu()" class="neon-text">MAIN MENU</button>
        </div>
        
        <div id="gameOver">
            <div class="game-over-content">
                <h2 class="game-over-title">SYSTEM FAILURE</h2>
                
                <div class="game-over-stats">
                    <div class="stat-row">
                        <span class="stat-label">Final Score</span>
                        <span class="stat-value" id="finalScore">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Kills</span>
                        <span class="stat-value" id="finalKills">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Waves Survived</span>
                        <span class="stat-value" id="finalWaves">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Max Combo</span>
                        <span class="stat-value" id="maxCombo">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Level Reached</span>
                        <span class="stat-value" id="finalLevel">1</span>
                    </div>
                </div>
                
                <div class="game-over-buttons">
                    <button id="restartBtn" class="btn-primary">
                        <span class="btn-icon">🔄</span>
                        <span class="btn-text">Reboot System</span>
                    </button>
                    <button onclick="showShop()" class="btn-secondary">
                        <span class="btn-icon">🔧</span>
                        <span class="btn-text">Upgrade Matrix</span>
                    </button>
                    <button onclick="showAchievements()" class="btn-secondary">
                        <span class="btn-icon">🏆</span>
                        <span class="btn-text">Achievements</span>
                    </button>
                    <button onclick="goToMenu()" class="btn-secondary">
                        <span class="btn-icon">🏠</span>
                        <span class="btn-text">Main Menu</span>
                    </button>
                </div>
            </div>

            <!-- Mission Control Panel -->
            <div id="missionControl" class="mission-control">
                <button class="close-mission-control" onclick="GameController.closeMissionControl()">×</button>
                <h2>Mission Control Center</h2>
                
                <div class="mission-tabs">
                    <button class="mission-tab active" onclick="GameController.showMissionTab('active')">Active Missions</button>
                    <button class="mission-tab" onclick="GameController.showMissionTab('available')">Available</button>
                    <button class="mission-tab" onclick="GameController.showMissionTab('completed')">Completed</button>
                </div>

                <div id="activeMissions" class="mission-list">
                    <!-- Active missions will be populated here -->
                </div>

                <div id="availableMissions" class="mission-list" style="display: none;">
                    <!-- Available missions will be populated here -->
                </div>

                <div id="completedMissions" class="mission-list" style="display: none;">
                    <!-- Completed missions will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOver');
        const shopScreen = document.getElementById('shop');
        const achievementScreen = document.getElementById('achievementScreen');
        const pauseMenu = document.getElementById('pauseMenu');
        const weaponWheel = document.getElementById('weaponWheel');
        
        // Audio context for sound effects
        let audioContext;
        let isMuted = false;
        
        // Set canvas sizes
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Enhanced Game state
        let gameState = 'start';
        let score = 0;
        let wave = 1;
        let kills = 0;
        let credits = 2000;
        let level = 1;
        let experience = 0;
        let nextLevelXP = 100;
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = 0;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let bulletTime = false;
        let bulletTimeTimer = 0;
        let screenShake = 0;
        let lastHitTime = 0;
        let difficulty = 1;
        let survivalTime = 0;
        let gameSpeed = 1;
        let environmentHazardLevel = 0;
        let economyMultiplier = 1;
        let perfectWaveStreak = 0;
        let damageDealtThisWave = 0;
        let damageTakenThisWave = 0;
        let totalPlayTime = 0;
        let sessionsPlayed = 0;
        let bestStreak = 0;
        let weaponKills = {};
        let enemyTypesKilled = {};
        let bossesKilled = 0;
        let perfectWaves = 0;
        let gameStats = {
            totalShots: 0,
            shotsHit: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            powerupsCollected: 0,
            abilitiesUsed: 0,
            timesSaved: 0,
            highestWave: 0,
            longestSurvival: 0
        };
        
        // Enhanced Upgrades System
        let upgrades = {
            health: 0,
            damage: 0,
            speed: 0,
            regen: 0,
            weapons: ['blaster'],
            armor: 0,
            criticalChance: 0,
            criticalDamage: 0,
            fireRate: 0,
            penetration: 0,
            explosiveRadius: 0,
            energyEfficiency: 0,
            shieldCapacity: 0,
            magneticRadius: 0,
            luck: 0,
            experienceBonus: 0,
            creditBonus: 0,
            ammoCapacity: 0,
            reloadSpeed: 0,
            movementTech: 0
        };
        
        // Research Tree System
        let researchTree = {
            weaponTech: { level: 0, maxLevel: 5, cost: 1000, unlocked: true },
            defensiveTech: { level: 0, maxLevel: 5, cost: 1200, unlocked: true },
            economicTech: { level: 0, maxLevel: 3, cost: 1500, unlocked: false },
            advancedAI: { level: 0, maxLevel: 3, cost: 2000, unlocked: false },
            nanobioTech: { level: 0, maxLevel: 4, cost: 2500, unlocked: false },
            quantumTech: { level: 0, maxLevel: 2, cost: 5000, unlocked: false }
        };
        
        // Mission System
        let activeMissions = [];
        let completedMissions = [];
        let missionTypes = [
            { id: 'killStreak', name: 'Kill Streak', description: 'Get {target} kills without dying', reward: 500 },
            { id: 'waveSpeed', name: 'Speed Demon', description: 'Complete wave in under {target} seconds', reward: 300 },
            { id: 'weaponMaster', name: 'Weapon Master', description: 'Get {target} kills with {weapon}', reward: 400 },
            { id: 'perfectWave', name: 'Perfect Wave', description: 'Complete wave without taking damage', reward: 750 },
            { id: 'economical', name: 'Economical', description: 'Complete wave without spending credits', reward: 200 },
            { id: 'abilityMaster', name: 'Ability Master', description: 'Use {ability} {target} times', reward: 350 }
        ];
        
        // Enhanced Weapons System
        const weapons = {
            blaster: { 
                name: 'Blaster', damage: 1, ammo: 30, fireRate: 150, spread: 0, color: '#00ffff', 
                piercing: false, accuracy: 0.95, range: 1000, energyCost: 1, unlockCost: 0,
                description: 'Standard energy weapon. Reliable and efficient.'
            },
            rifle: { 
                name: 'Assault Rifle', damage: 2, ammo: 20, fireRate: 200, spread: 0.1, color: '#ff8800', 
                piercing: false, accuracy: 0.85, range: 1200, energyCost: 2, unlockCost: 800,
                description: 'High damage, moderate spread. Good for sustained combat.'
            },
            shotgun: { 
                name: 'Shotgun', damage: 1, ammo: 8, fireRate: 400, spread: 0.3, color: '#ff0080', 
                piercing: false, accuracy: 0.7, range: 400, energyCost: 4, unlockCost: 1000,
                description: 'Close range devastation. Fires multiple projectiles.'
            },
            plasma: { 
                name: 'Plasma Cannon', damage: 3, ammo: 15, fireRate: 250, spread: 0, color: '#80ff00', 
                piercing: false, accuracy: 0.9, range: 800, energyCost: 3, unlockCost: 1200,
                description: 'High energy plasma bolts. Excellent damage output.'
            },
            laser: { 
                name: 'Laser Rifle', damage: 2, ammo: 25, fireRate: 100, spread: 0, color: '#ff0000', 
                piercing: true, accuracy: 1.0, range: 1500, energyCost: 2, unlockCost: 1500,
                description: 'Piercing laser beam. Perfect accuracy, penetrates enemies.'
            },
            rocket: { 
                name: 'Rocket Launcher', damage: 5, ammo: 5, fireRate: 800, spread: 0, color: '#ffff00', 
                piercing: false, explosive: true, accuracy: 0.8, range: 1000, energyCost: 8, unlockCost: 2000,
                description: 'Explosive warheads. Massive area damage.'
            },
            flamethrower: { 
                name: 'Flamethrower', damage: 1, ammo: 50, fireRate: 50, spread: 0.2, color: '#ff4400', 
                piercing: false, flame: true, accuracy: 0.6, range: 300, energyCost: 1, unlockCost: 1800,
                description: 'Continuous flame stream. Damages over time.'
            },
            railgun: { 
                name: 'Railgun', damage: 8, ammo: 3, fireRate: 2000, spread: 0, color: '#8800ff', 
                piercing: true, charge: true, accuracy: 1.0, range: 2000, energyCost: 12, unlockCost: 3000,
                description: 'Charge-based electromagnetic projectile. Incredible damage.'
            },
            chaingun: {
                name: 'Chain Gun', damage: 1, ammo: 100, fireRate: 80, spread: 0.15, color: '#ffaa00',
                piercing: false, accuracy: 0.75, range: 900, energyCost: 1, unlockCost: 2200,
                description: 'High rate of fire. Suppressive capabilities.'
            },
            neutrino: {
                name: 'Neutrino Beam', damage: 4, ammo: 12, fireRate: 300, spread: 0, color: '#00aaff',
                piercing: true, phasing: true, accuracy: 0.95, range: 1800, energyCost: 6, unlockCost: 4000,
                description: 'Quantum weapon. Phases through all matter except targets.'
            }
        };
        
        // Environmental hazards
        let hazards = [];
        let pickups = [];
        let screenEffects = [];
        
        // Achievement system
        let achievements = {
            firstKill: { name: 'First Blood', description: 'Kill your first enemy', unlocked: false },
            wave5: { name: 'Survivor', description: 'Survive 5 waves', unlocked: false },
            wave10: { name: 'Veteran', description: 'Survive 10 waves', unlocked: false },
            combo10: { name: 'Combo Master', description: 'Achieve 10x combo', unlocked: false },
            combo25: { name: 'Chain Killer', description: 'Achieve 25x combo', unlocked: false },
            kills100: { name: 'Centurion', description: 'Kill 100 enemies', unlocked: false },
            kills500: { name: 'Executioner', description: 'Kill 500 enemies', unlocked: false },
            bossKiller: { name: 'Boss Slayer', description: 'Kill a boss enemy', unlocked: false },
            perfectWave: { name: 'Untouchable', description: 'Complete a wave without taking damage', unlocked: false },
            allWeapons: { name: 'Arsenal', description: 'Unlock all weapons', unlocked: false },
            multiKill: { name: 'Multi-Kill', description: 'Kill 5 enemies within 2 seconds', unlocked: false },
            meteorDestroyer: { name: 'Meteor Destroyer', description: 'Destroy 10 meteors', unlocked: false },
            wormholeExplorer: { name: 'Wormhole Explorer', description: 'Use a wormhole 5 times', unlocked: false },
            droneCommander: { name: 'Drone Commander', description: 'Have 3 drones active simultaneously', unlocked: false },
            barrierBreaker: { name: 'Barrier Breaker', description: 'Destroy 20 barriers', unlocked: false },
            eventSurvivor: { name: 'Event Survivor', description: 'Survive 5 special events', unlocked: false }
        };
        
        // Enhanced Player System
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 15,
            speed: 5,
            health: 100,
            maxHealth: 100,
            energy: 100,
            maxEnergy: 100,
            currentWeapon: 'blaster',
            ammo: 30,
            reloading: false,
            angle: 0,
            shield: false,
            shieldTimer: 0,
            shieldHealth: 0,
            maxShieldHealth: 0,
            dashCooldown: 0,
            lastShot: 0,
            invulnerable: false,
            invulnerableTimer: 0,
            healthRegen: 0,
            regenTimer: 0,
            energyRegen: 2,
            energyRegenTimer: 0,
            charging: false,
            chargeTime: 0,
            kills: 0,
            meteorsDestroyed: 0,
            wormholeUses: 0,
            barriersDestroyed: 0,
            eventsCompleted: 0,
            armor: 0,
            criticalChance: 0.05,
            criticalMultiplier: 2.0,
            penetrationLevel: 0,
            magneticRange: 0,
            luck: 0,
            overcharged: false,
            overchargeTimer: 0,
            weaponHeat: 0,
            maxWeaponHeat: 100,
            coolingRate: 2,
            accuracy: 1.0,
            multiShot: 1,
            ricochetCount: 0,
            specialAmmo: { type: 'none', count: 0 },
            statusEffects: [],
            killStreak: 0,
            lastKillTime: 0,
            perfectWaveBonus: false
        };
        
        // Game objects
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let enemyBullets = [];
        let explosions = [];
        let lasers = [];
        let barriers = [];
        let drones = [];
        let meteors = [];
        let wormholes = [];
        let specialEvents = [];
        let multiKillTimer = 0;
        
        // Enhanced Abilities
        let abilities = {
            shield: { cooldown: 0, maxCooldown: 8000 },
            dash: { cooldown: 0, maxCooldown: 4000 },
            bomb: { cooldown: 0, maxCooldown: 12000 },
            time: { cooldown: 0, maxCooldown: 15000 },
            heal: { cooldown: 0, maxCooldown: 10000 }
        };
        
        // Sound effects
        function playSound(frequency, type = 'sine', duration = 0.1) {
            if (isMuted || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            // Apply volume settings
            const masterVol = gameSettings.masterVolume / 100;
            const sfxVol = gameSettings.sfxVolume / 100;
            const finalVolume = 0.1 * masterVol * sfxVol;
            
            gainNode.gain.setValueAtTime(finalVolume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        // Initialize audio
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // Classes
        class Bullet {
            constructor(x, y, angle, weapon) {
                this.x = x;
                this.y = y;
                this.weapon = weapon;
                this.piercing = weapon.piercing;
                this.explosive = weapon.explosive;
                this.hits = 0;
                const spread = weapon.spread * (Math.random() - 0.5);
                this.vx = Math.cos(angle + spread) * 10;
                this.vy = Math.sin(angle + spread) * 10;
                this.size = weapon.explosive ? 5 : 3;
                this.life = 120;
                this.damage = weapon.damage * (1 + upgrades.damage * 0.5);
                this.trail = [];
                // Add physics properties
                this.gravity = weapon.explosive ? 0.05 : 0.02;
                this.friction = 0.995;
                this.mass = weapon.explosive ? 3 : 1;
                this.spin = (Math.random() - 0.5) * 0.2;
                this.rotation = 0;
            }
            
            update() {
                const speed = bulletTime ? 0.3 : 1;
                
                // Apply physics
                if (!this.weapon.piercing) { // Piercing bullets ignore gravity
                    this.vy += this.gravity;
                }
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.rotation += this.spin;
                
                this.x += this.vx * speed;
                this.y += this.vy * speed;
                this.life--;
                
                // Add trail effect
                this.trail.push({ x: this.x, y: this.y, life: 10, rotation: this.rotation });
                this.trail = this.trail.filter(t => t.life-- > 0);
                
                // Bounce explosive bullets off walls
                if (this.explosive) {
                    if (this.x <= 0 || this.x >= canvas.width) {
                        this.vx *= -0.7;
                        this.x = Math.max(0, Math.min(canvas.width, this.x));
                        createParticles(this.x, this.y, this.weapon.color, 3);
                    }
                    if (this.y <= 0 || this.y >= canvas.height) {
                        this.vy *= -0.7;
                        this.y = Math.max(0, Math.min(canvas.height, this.y));
                        createParticles(this.x, this.y, this.weapon.color, 3);
                    }
                }
                
                return this.life > 0 && this.x > -100 && this.x < canvas.width + 100 && this.y > -100 && this.y < canvas.height + 100;
            }
            
            draw() {
                // Draw trail with rotation
                ctx.save();
                this.trail.forEach((point, i) => {
                    ctx.globalAlpha = (point.life / 10) * 0.5;
                    ctx.fillStyle = this.weapon.color;
                    ctx.save();
                    ctx.translate(point.x, point.y);
                    ctx.rotate(point.rotation || 0);
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                ctx.restore();
                
                // Draw bullet with rotation
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.life / 120;
                ctx.fillStyle = this.weapon.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.weapon.color;
                
                if (this.explosive) {
                    // Draw rocket shape
                    ctx.fillRect(-this.size, -this.size/2, this.size*2, this.size);
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(-this.size/2, -this.size/4, this.size, this.size/2);
                    // Glowing effect for rockets
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.size, -this.size/2, this.size*2, this.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }
        
        class Laser {
            constructor(x, y, angle, length = 1000) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.length = length;
                this.life = 10;
                this.damage = 2 * (1 + upgrades.damage * 0.5);
            }
            
            update() {
                this.life--;
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / 10;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0000';
                
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * this.length,
                    this.y + Math.sin(this.angle) * this.length
                );
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Advanced AI System
        class AIBehavior {
            constructor(enemy) {
                this.enemy = enemy;
                this.state = 'idle';
                this.target = null;
                this.pathfinding = [];
                this.decisionTimer = 0;
                this.flankDirection = Math.random() > 0.5 ? 1 : -1;
                this.retreatThreshold = enemy.maxHealth * 0.3;
                this.aggressionLevel = Math.random();
                this.teamwork = enemy.type === 'healer' || enemy.type === 'support';
                this.lastPlayerPosition = { x: 0, y: 0 };
                this.predictedPlayerPosition = { x: 0, y: 0 };
                this.formationPosition = null;
                this.commandRadius = 150;
            }
            
            update(enemies) {
                this.decisionTimer++;
                this.updatePrediction();
                
                switch(this.enemy.type) {
                    case 'commander':
                        this.commanderBehavior(enemies);
                        break;
                    case 'sniper':
                        this.sniperBehavior();
                        break;
                    case 'flanker':
                        this.flankerBehavior();
                        break;
                    case 'berserker':
                        this.berserkerBehavior();
                        break;
                    case 'support':
                        this.supportBehavior(enemies);
                        break;
                    case 'adaptive':
                        this.adaptiveBehavior();
                        break;
                    default:
                        this.basicBehavior();
                }
            }
            
            updatePrediction() {
                // Predict player movement
                const playerVel = {
                    x: player.x - this.lastPlayerPosition.x,
                    y: player.y - this.lastPlayerPosition.y
                };
                
                this.predictedPlayerPosition = {
                    x: player.x + playerVel.x * 30,
                    y: player.y + playerVel.y * 30
                };
                
                this.lastPlayerPosition = { x: player.x, y: player.y };
            }
            
            commanderBehavior(enemies) {
                // Command nearby enemies
                const nearbyEnemies = enemies.filter(e => 
                    e !== this.enemy && distance(this.enemy, e) < this.commandRadius
                );
                
                nearbyEnemies.forEach(ally => {
                    if (ally.ai && !ally.ai.formationPosition) {
                        const angle = Math.atan2(ally.y - this.enemy.y, ally.x - this.enemy.x);
                        ally.ai.formationPosition = {
                            x: this.enemy.x + Math.cos(angle) * 80,
                            y: this.enemy.y + Math.sin(angle) * 80
                        };
                    }
                });
                
                // Strategic positioning
                if (this.decisionTimer % 120 === 0) {
                    this.chooseStrategicPosition();
                }
            }
            
            sniperBehavior() {
                const dist = distance(this.enemy, player);
                
                if (dist < 200) {
                    // Too close, retreat
                    this.state = 'retreat';
                    this.moveAwayFrom(player);
                } else if (dist > 600) {
                    // Too far, advance slightly
                    this.state = 'advance';
                    this.moveTowards(this.predictedPlayerPosition, 0.5);
                } else {
                    // Perfect range, maintain position and shoot
                    this.state = 'attack';
                    this.enemy.shootTimer = Math.max(this.enemy.shootTimer, this.enemy.getShootRate() - 10);
                }
            }
            
            flankerBehavior() {
                const angleToPlayer = Math.atan2(player.y - this.enemy.y, player.x - this.enemy.x);
                const flankAngle = angleToPlayer + (Math.PI / 2) * this.flankDirection;
                
                const targetX = player.x + Math.cos(flankAngle) * 120;
                const targetY = player.y + Math.sin(flankAngle) * 120;
                
                this.moveTowards({ x: targetX, y: targetY }, 1.2);
                
                // Switch flanking direction occasionally
                if (this.decisionTimer % 180 === 0) {
                    this.flankDirection *= -1;
                }
            }
            
            berserkerBehavior() {
                if (this.enemy.health < this.enemy.maxHealth * 0.5) {
                    // Enraged mode
                    this.enemy.speed *= 1.5;
                    this.enemy.shootTimer += 2; // Faster shooting
                    this.moveTowards(player, 1.8);
                } else {
                    this.moveTowards(player, 1.0);
                }
            }
            
            supportBehavior(enemies) {
                const woundedAllies = enemies.filter(e => 
                    e !== this.enemy && 
                    e.health < e.maxHealth * 0.7 &&
                    distance(this.enemy, e) < 200
                );
                
                if (woundedAllies.length > 0) {
                    // Move to heal wounded allies
                    this.moveTowards(woundedAllies[0], 0.8);
                } else {
                    // Stay behind other enemies
                    const frontlineEnemies = enemies.filter(e => 
                        e !== this.enemy && distance(e, player) < distance(this.enemy, player)
                    );
                    
                    if (frontlineEnemies.length > 0) {
                        const avgPos = this.getAveragePosition(frontlineEnemies);
                        this.moveAwayFrom(avgPos, 0.5);
                    }
                }
            }
            
            adaptiveBehavior() {
                // Adapt based on player behavior
                const playerSpeed = distance(player, this.lastPlayerPosition);
                const playerAggression = player.killStreak > 5;
                
                if (playerSpeed > 3) {
                    // Player is mobile, use hit-and-run
                    this.hit_and_run();
                } else if (playerAggression) {
                    // Player is aggressive, be defensive
                    this.defensive();
                } else {
                    // Normal behavior
                    this.basicBehavior();
                }
            }
            
            moveTowards(target, speedMult = 1) {
                const dx = target.x - this.enemy.x;
                const dy = target.y - this.enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.enemy.x += (dx / dist) * this.enemy.speed * speedMult;
                    this.enemy.y += (dy / dist) * this.enemy.speed * speedMult;
                }
            }
            
            moveAwayFrom(target, speedMult = 1) {
                const dx = this.enemy.x - target.x;
                const dy = this.enemy.y - target.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.enemy.x += (dx / dist) * this.enemy.speed * speedMult;
                    this.enemy.y += (dy / dist) * this.enemy.speed * speedMult;
                }
            }
            
            getAveragePosition(entities) {
                const sum = entities.reduce((acc, e) => ({
                    x: acc.x + e.x,
                    y: acc.y + e.y
                }), { x: 0, y: 0 });
                
                return {
                    x: sum.x / entities.length,
                    y: sum.y / entities.length
                };
            }
            
            basicBehavior() {
                // Standard behavior - move toward player
                this.moveTowards(player, 1.0);
            }
            
            hit_and_run() {
                // Attack briefly then retreat
                const dist = distance(this.enemy, player);
                if (dist < 100) {
                    this.moveAwayFrom(player, 1.2);
                } else if (dist > 200) {
                    this.moveTowards(player, 0.8);
                }
            }
            
            defensive() {
                // Maintain distance and be cautious
                const dist = distance(this.enemy, player);
                if (dist < 150) {
                    this.moveAwayFrom(player, 0.8);
                } else if (dist > 250) {
                    this.moveTowards(player, 0.6);
                }
            }
            
            chooseStrategicPosition() {
                // Choose a strategic position based on current situation
                const playerHealth = player.health / player.maxHealth;
                const enemyHealth = this.enemy.health / this.enemy.maxHealth;
                
                if (playerHealth < 0.3) {
                    // Player is weak, be aggressive
                    this.moveTowards(player, 1.5);
                } else if (enemyHealth < 0.3) {
                    // Enemy is weak, be defensive
                    this.moveAwayFrom(player, 1.2);
                } else {
                    // Balanced approach
                    this.moveTowards(player, 1.0);
                }
            }
            
            basicBehavior() {
                // Standard behavior - move toward player
                this.moveTowards(player, 1.0);
            }
            
            hit_and_run() {
                // Attack briefly then retreat
                const dist = distance(this.enemy, player);
                if (dist < 100) {
                    this.moveAwayFrom(player, 1.2);
                } else if (dist > 200) {
                    this.moveTowards(player, 0.8);
                }
            }
            
            defensive() {
                // Maintain distance and be cautious
                const dist = distance(this.enemy, player);
                if (dist < 150) {
                    this.moveAwayFrom(player, 0.8);
                } else if (dist > 250) {
                    this.moveTowards(player, 0.6);
                }
            }
            
            chooseStrategicPosition() {
                // Choose a strategic position based on current situation
                const playerHealth = player.health / player.maxHealth;
                const enemyHealth = this.enemy.health / this.enemy.maxHealth;
                
                if (playerHealth < 0.3) {
                    // Player is weak, be aggressive
                    this.moveTowards(player, 1.5);
                } else if (enemyHealth < 0.3) {
                    // Enemy is weak, be defensive
                    this.moveAwayFrom(player, 1.2);
                } else {
                    // Balanced approach
                    this.moveTowards(player, 1.0);
                }
            }
            
            basicBehavior() {
                // Standard behavior - move toward player
                this.moveTowards(player, 1.0);
            }
            
            hit_and_run() {
                // Attack briefly then retreat
                const dist = distance(this.enemy, player);
                if (dist < 100) {
                    this.moveAwayFrom(player, 1.2);
                } else if (dist > 200) {
                    this.moveTowards(player, 0.8);
                }
            }
            
            defensive() {
                // Maintain distance and be cautious
                const dist = distance(this.enemy, player);
                if (dist < 150) {
                    this.moveAwayFrom(player, 0.8);
                } else if (dist > 250) {
                    this.moveTowards(player, 0.6);
                }
            }
            
            chooseStrategicPosition() {
                // Choose a strategic position based on current situation
                const playerHealth = player.health / player.maxHealth;
                const enemyHealth = this.enemy.health / this.enemy.maxHealth;
                
                if (playerHealth < 0.3) {
                    // Player is weak, be aggressive
                    this.moveTowards(player, 1.5);
                } else if (enemyHealth < 0.3) {
                    // Enemy is weak, be defensive
                    this.moveAwayFrom(player, 1.2);
                } else {
                    // Balanced approach
                    this.moveTowards(player, 1.0);
                }
            }
            
            basicBehavior() {
                // Standard behavior - move toward player
                this.moveTowards(player, 1.0);
            }
            
            hit_and_run() {
                // Attack briefly then retreat
                const dist = distance(this.enemy, player);
                if (dist < 100) {
                    this.moveAwayFrom(player, 1.2);
                } else if (dist > 200) {
                    this.moveTowards(player, 0.8);
                }
            }
            
            defensive() {
                // Maintain distance and be cautious
                const dist = distance(this.enemy, player);
                if (dist < 150) {
                    this.moveAwayFrom(player, 0.8);
                } else if (dist > 250) {
                    this.moveTowards(player, 0.6);
                }
            }
            
            chooseStrategicPosition() {
                // Choose a strategic position based on current situation
                const playerHealth = player.health / player.maxHealth;
                const enemyHealth = this.enemy.health / this.enemy.maxHealth;
                
                if (playerHealth < 0.3) {
                    // Player is weak, be aggressive
                    this.moveTowards(player, 1.5);
                } else if (enemyHealth < 0.3) {
                    // Enemy is weak, be defensive
                    this.moveAwayFrom(player, 1.2);
                } else {
                    // Balanced approach
                    this.moveTowards(player, 1.0);
                }
            }
            
            basicBehavior() {
                // Standard behavior - move toward player
                this.moveTowards(player, 1.0);
            }
            
            hit_and_run() {
                // Attack briefly then retreat
                const dist = distance(this.enemy, player);
                if (dist < 100) {
                    this.moveAwayFrom(player, 1.2);
                } else if (dist > 200) {
                    this.moveTowards(player, 0.8);
                }
            }
            
            defensive() {
                // Maintain distance and be cautious
                const dist = distance(this.enemy, player);
                if (dist < 150) {
                    this.moveAwayFrom(player, 0.8);
                } else if (dist > 250) {
                    this.moveTowards(player, 0.6);
                }
            }
            
            chooseStrategicPosition() {
                // Choose a strategic position based on current situation
                const playerHealth = player.health / player.maxHealth;
                const enemyHealth = this.enemy.health / this.enemy.maxHealth;
                
                if (playerHealth < 0.3) {
                    // Player is weak, be aggressive
                    this.moveTowards(player, 1.5);
                } else if (enemyHealth < 0.3) {
                    // Enemy is weak, be defensive
                    this.moveAwayFrom(player, 1.2);
                } else {
                    // Balanced approach
                    this.moveTowards(player, 1.0);
                }
            }
            
            basicBehavior() {
                // Standard behavior - move toward player
                this.moveTowards(player, 1.0);
            }
            
            hit_and_run() {
                // Attack briefly then retreat
                const dist = distance(this.enemy, player);
                if (dist < 100) {
                    this.moveAwayFrom(player, 1.2);
                } else if (dist > 200) {
                    this.moveTowards(player, 0.8);
                }
            }
            
            defensive() {
                // Maintain distance and be cautious
                const dist = distance(this.enemy, player);
                if (dist < 150) {
                    this.moveAwayFrom(player, 0.8);
                } else if (dist > 250) {
                    this.moveTowards(player, 0.6);
                }
            }
            
            chooseStrategicPosition() {
                // Choose a strategic position based on current situation
                const playerHealth = player.health / player.maxHealth;
                const enemyHealth = this.enemy.health / this.enemy.maxHealth;
                
                if (playerHealth < 0.3) {
                    // Player is weak, be aggressive
                    this.moveTowards(player, 1.5);
                } else if (enemyHealth < 0.3) {
                    // Enemy is weak, be defensive
                    this.moveAwayFrom(player, 1.2);
                } else {
                    // Balanced approach
                    this.moveTowards(player, 1.0);
                }
            }
        }
        
        class Enemy {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = this.getSize(type);
                this.speed = this.getSpeed(type);
                this.health = this.getHealth(type);
                this.maxHealth = this.health;
                this.shootTimer = 0;
                this.angle = 0;
                this.color = this.getColor(type);
                this.credits = this.getCredits(type);
                this.xp = this.getXP(type);
                this.lastDamageTime = 0;
                this.behavior = this.getBehavior(type);
                this.specialTimer = 0;
                this.shieldHealth = type === 'shielded' ? 5 : 0;
                this.teleportTimer = type === 'teleporter' ? 0 : -1;
                this.splitCount = type === 'splitter' ? 2 : 0;
                this.healTimer = type === 'healer' ? 0 : -1;
                this.chargeDirection = type === 'charger' ? null : null;
                this.chargeSpeed = type === 'charger' ? 8 : 0;
                this.stealthTimer = type === 'stealth' ? 0 : -1;
                this.alpha = 1;
                this.ai = new AIBehavior(this);
                this.statusEffects = [];
                this.armor = this.getArmor(type);
                this.abilities = this.getAbilities(type);
                this.formation = null;
                this.rank = this.getRank(type);
                this.experienceGained = 0;
                this.evolutionTimer = 0;
                this.canEvolve = ['basic', 'fast'].includes(type);
                // Add physics properties
                this.vx = 0;
                this.vy = 0;
                this.acceleration = 0.05;
                this.friction = 0.92;
                this.mass = type === 'boss' ? 5 : type === 'heavy' ? 3 : 1;
                this.rotation = 0;
                this.angularVelocity = 0;
                this.knockbackResistance = type === 'heavy' ? 0.8 : type === 'boss' ? 0.9 : 0.3;
            }
            
            getSize(type) {
                const sizes = {
                    boss: 30, heavy: 20, fast: 10, basic: 15,
                    shielded: 18, teleporter: 12, splitter: 16,
                    healer: 14, charger: 22, stealth: 13
                };
                return sizes[type] || 15;
            }
            
            getSpeed(type) {
                const speeds = {
                    fast: 1.8, boss: 0.5, heavy: 0.7, basic: 0.9,
                    shielded: 0.8, teleporter: 1.2, splitter: 1.0,
                    healer: 0.6, charger: 0.5, stealth: 1.3
                };
                return speeds[type] || 0.9;
            }
            
            getHealth(type) {
                const healths = {
                    boss: 25, heavy: 12, fast: 2, basic: 5,
                    shielded: 8, teleporter: 4, splitter: 6,
                    healer: 10, charger: 15, stealth: 3
                };
                return healths[type] || 5;
            }
            
            getColor(type) {
                const colors = {
                    boss: '#ff0000', heavy: '#ff8800', fast: '#ffff00', basic: '#ff0080',
                    shielded: '#00ffff', teleporter: '#8800ff', splitter: '#ff4400',
                    healer: '#00ff00', charger: '#ff0044', stealth: '#666666'
                };
                return colors[type] || '#ff0080';
            }
            
            getCredits(type) {
                const credits = {
                    boss: 300, heavy: 100, fast: 25, basic: 50,
                    shielded: 80, teleporter: 75, splitter: 90,
                    healer: 120, charger: 110, stealth: 85
                };
                return credits[type] || 50;
            }
            
            getXP(type) {
                const xps = {
                    boss: 50, heavy: 25, fast: 10, basic: 15,
                    shielded: 20, teleporter: 18, splitter: 22,
                    healer: 30, charger: 25, stealth: 20
                };
                return xps[type] || 15;
            }
            
            getBehavior(type) {
                const behaviors = {
                    boss: 'aggressive', fast: 'erratic', basic: 'normal',
                    heavy: 'normal', shielded: 'defensive', teleporter: 'teleport',
                    splitter: 'normal', healer: 'support', charger: 'charge',
                    stealth: 'stealth'
                };
                return behaviors[type] || 'normal';
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            getArmor(type) {
                const armors = {
                    boss: 0.3, heavy: 0.2, shielded: 0.15, charger: 0.1,
                    basic: 0, fast: 0, teleporter: 0, splitter: 0,
                    healer: 0.05, stealth: 0
                };
                return armors[type] || 0;
            }
            
            getAbilities(type) {
                const abilities = {
                    boss: ['rage', 'summon'],
                    heavy: ['charge'],
                    shielded: ['shield_boost'],
                    teleporter: ['teleport'],
                    splitter: ['split'],
                    healer: ['heal_others'],
                    charger: ['ram'],
                    stealth: ['cloak']
                };
                return abilities[type] || [];
            }
            
            getRank(type) {
                const ranks = {
                    boss: 5, heavy: 3, shielded: 2, teleporter: 2,
                    splitter: 2, healer: 3, charger: 3, stealth: 2,
                    basic: 1, fast: 1
                };
                return ranks[type] || 1;
            }
            
            update() {
                const speed = bulletTime ? 0.3 : 1;
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                this.specialTimer++;
                this.evolutionTimer++;
                
                // Update AI behavior
                this.ai.update(enemies);
                
                // Update status effects
                this.updateStatusEffects();
                
                // Check for evolution
                if (this.canEvolve && this.evolutionTimer > 1800 && this.experienceGained > 50) {
                    this.evolve();
                }
                
                // Enhanced behaviors with AI integration
                switch(this.behavior) {
                    case 'erratic':
                        if (this.specialTimer > 60) {
                            this.angle += (Math.random() - 0.5) * 0.5;
                            this.specialTimer = 0;
                        }
                        break;
                        
                    case 'aggressive':
                        this.speed = 1.5 * (1 + this.rank * 0.2);
                        if (this.health < this.maxHealth * 0.5) {
                            this.speed = 2.5 * (1 + this.rank * 0.2);
                        }
                        break;
                        
                    case 'teleport':
                        if (this.teleportTimer > 180 && Math.random() < 0.05) {
                            // Smarter teleportation - avoid player's vicinity
                            let newX, newY;
                            do {
                                newX = Math.random() * canvas.width;
                                newY = Math.random() * canvas.height;
                            } while (distance({x: newX, y: newY}, player) < 150);
                            
                            this.x = newX;
                            this.y = newY;
                            this.teleportTimer = 0;
                            createParticles(this.x, this.y, this.color, 15);
                        }
                        this.teleportTimer++;
                        break;
                        
                    case 'charge':
                        if (this.specialTimer > 120 && !this.chargeDirection) {
                            // Predict player position for charging
                            const playerVel = {
                                x: (player.x - this.ai.lastPlayerPosition.x) * 10,
                                y: (player.y - this.ai.lastPlayerPosition.y) * 10
                            };
                            const targetX = player.x + playerVel.x;
                            const targetY = player.y + playerVel.y;
                            
                            this.chargeDirection = Math.atan2(targetY - this.y, targetX - this.x);
                            this.speed = this.chargeSpeed;
                        }
                        if (this.chargeDirection) {
                            if (this.specialTimer > 180) {
                                this.chargeDirection = null;
                                this.speed = this.getSpeed(this.type);
                                this.specialTimer = 0;
                            }
                        }
                        break;
                        
                    case 'stealth':
                        if (this.stealthTimer > 300) {
                            // Smart stealth - become invisible when player isn't looking
                            const playerLookAngle = player.angle;
                            const angleToThis = Math.atan2(this.y - player.y, this.x - player.x);
                            const angleDiff = Math.abs(playerLookAngle - angleToThis);
                            
                            this.alpha = angleDiff > Math.PI / 3 ? 0.2 : 1;
                            this.stealthTimer = 0;
                        }
                        this.stealthTimer++;
                        break;
                        
                    case 'support':
                        if (this.healTimer > 240) {
                            // Enhanced healing with priority system
                            const woundedEnemies = enemies.filter(enemy => 
                                enemy !== this && 
                                distance(this, enemy) < 100 && 
                                enemy.health < enemy.maxHealth
                            ).sort((a, b) => (a.health / a.maxHealth) - (b.health / b.maxHealth));
                            
                            if (woundedEnemies.length > 0) {
                                const target = woundedEnemies[0];
                                target.health = Math.min(target.maxHealth, target.health + 3 + this.rank);
                                createParticles(target.x, target.y, '#00ff00', 8);
                                
                                // Also provide temporary damage boost
                                target.statusEffects.push({
                                    type: 'damage_boost',
                                    duration: 300,
                                    value: 1.5
                                });
                            }
                            this.healTimer = 0;
                        }
                        this.healTimer++;
                        break;
                }
                
                // Physics-based movement with AI influence
                if (dist > 0) {
                    let moveAngle = Math.atan2(dy, dx);
                    
                    // Apply AI modifications
                    if (this.ai.state === 'retreat') {
                        moveAngle += Math.PI; // Reverse direction
                    } else if (this.ai.state === 'flank') {
                        moveAngle += (Math.PI / 2) * this.ai.flankDirection;
                    }
                    
                    if (this.behavior === 'erratic') {
                        moveAngle += this.angle;
                        this.angularVelocity += (Math.random() - 0.5) * 0.1;
                    } else if (this.behavior === 'charge' && this.chargeDirection) {
                        moveAngle = this.chargeDirection;
                    }
                    
                    // Formation movement
                    if (this.ai.formationPosition) {
                        const formDx = this.ai.formationPosition.x - this.x;
                        const formDy = this.ai.formationPosition.y - this.y;
                        const formDist = Math.sqrt(formDx * formDx + formDy * formDy);
                        
                        if (formDist > 30) {
                            moveAngle = Math.atan2(formDy, formDx);
                        }
                    }
                    
                    // Apply acceleration instead of direct movement
                    const targetVx = Math.cos(moveAngle) * this.speed;
                    const targetVy = Math.sin(moveAngle) * this.speed;
                    
                    this.vx += (targetVx - this.vx) * this.acceleration;
                    this.vy += (targetVy - this.vy) * this.acceleration;
                    
                    // Apply friction
                    this.vx *= this.friction;
                    this.vy *= this.friction;
                    this.angularVelocity *= 0.95;
                    
                    // Update position
                    this.x += this.vx * speed;
                    this.y += this.vy * speed;
                    this.rotation += this.angularVelocity;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Keep enemies on screen with bouncing
                    if (this.x <= this.size || this.x >= canvas.width - this.size) {
                        this.vx *= -0.8;
                        this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                        this.angularVelocity += (Math.random() - 0.5) * 0.3;
                    }
                    if (this.y <= this.size || this.y >= canvas.height - this.size) {
                        this.vy *= -0.8;
                        this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                        this.angularVelocity += (Math.random() - 0.5) * 0.3;
                    }
                }
                
                // Enhanced shooting logic
                this.shootTimer++;
                const shootRate = this.getShootRate() * (1 - this.rank * 0.1);
                
                // Accuracy-based shooting
                const accuracy = this.getAccuracy();
                const shouldShoot = this.shootTimer > shootRate + Math.random() * 30;
                const canHitPlayer = Math.random() < accuracy;
                
                if (shouldShoot && canHitPlayer && dist < this.getRange()) {
                    this.shoot();
                    this.shootTimer = 0;
                }
                
                // Gain experience over time
                if (this.specialTimer % 60 === 0) {
                    this.experienceGained++;
                }
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            updateStatusEffects() {
                this.statusEffects = this.statusEffects.filter(effect => {
                    effect.duration--;
                    
                    // Apply effect
                    switch(effect.type) {
                        case 'damage_boost':
                            // Handled in damage calculation
                            break;
                        case 'speed_boost':
                            // Handled in movement
                            break;
                        case 'heal_over_time':
                            if (effect.duration % 60 === 0) {
                                this.health = Math.min(this.maxHealth, this.health + effect.value);
                            }
                            break;
                    }
                    
                    return effect.duration > 0;
                });
            }
            
            evolve() {
                // Evolve basic enemy types to more advanced forms
                if (this.type === 'basic' && Math.random() < 0.3) {
                    const evolutions = ['heavy', 'fast', 'shielded'];
                    const newType = evolutions[Math.floor(Math.random() * evolutions.length)];
                    this.type = newType;
                    this.color = this.getColor(newType);
                    this.health = this.getHealth(newType);
                    this.maxHealth = this.health;
                    this.speed = this.getSpeed(newType);
                    this.size = this.getSize(newType);
                    this.behavior = this.getBehavior(newType);
                    this.armor = this.getArmor(newType);
                    this.abilities = this.getAbilities(newType);
                    this.rank = this.getRank(newType);
                    
                    createParticles(this.x, this.y, this.color, 20);
                    showNotification('Enemy Evolved!');
                }
                
                this.canEvolve = false;
            }
            
            getShootRate() {
                const rates = {
                    boss: 40, fast: 180, heavy: 80, basic: 120,
                    shielded: 150, teleporter: 140, splitter: 110,
                    healer: 200, charger: 100, stealth: 160
                };
                return rates[this.type] || 120;
            }
            
            getAccuracy() {
                const accuracies = {
                    boss: 0.9, heavy: 0.8, shielded: 0.85, basic: 0.7,
                    fast: 0.6, teleporter: 0.75, splitter: 0.7,
                    healer: 0.6, charger: 0.5, stealth: 0.8
                };
                return accuracies[this.type] || 0.7;
            }
            
            getRange() {
                const ranges = {
                    boss: 300, heavy: 250, shielded: 200, basic: 180,
                    fast: 150, teleporter: 220, splitter: 180,
                    healer: 200, charger: 120, stealth: 200
                };
                return ranges[this.type] || 180;
            }
            
            getAccuracy() {
                const accuracies = {
                    boss: 0.9, heavy: 0.8, shielded: 0.85, basic: 0.7,
                    fast: 0.6, teleporter: 0.75, splitter: 0.7,
                    healer: 0.6, charger: 0.5, stealth: 0.8
                };
                return accuracies[this.type] || 0.7;
            }
            
            getRange() {
                const ranges = {
                    boss: 300, heavy: 250, shielded: 200, basic: 180,
                    fast: 150, teleporter: 220, splitter: 180,
                    healer: 200, charger: 120, stealth: 200
                };
                return ranges[this.type] || 180;
            }
            
            getAccuracy() {
                const accuracies = {
                    boss: 0.9, heavy: 0.8, shielded: 0.85, basic: 0.7,
                    fast: 0.6, teleporter: 0.75, splitter: 0.7,
                    healer: 0.6, charger: 0.5, stealth: 0.8
                };
                return accuracies[this.type] || 0.7;
            }
            
            getRange() {
                const ranges = {
                    boss: 300, heavy: 250, shielded: 200, basic: 180,
                    fast: 150, teleporter: 220, splitter: 180,
                    healer: 200, charger: 120, stealth: 200
                };
                return ranges[this.type] || 180;
            }
            
            shoot() {
                if (this.type === 'boss') {
                    // Boss shoots in spread pattern
                    for (let i = 0; i < 8; i++) {
                        const angle = this.angle + (i * Math.PI / 4);
                        enemyBullets.push(new EnemyBullet(this.x, this.y, angle, 'boss'));
                    }
                } else if (this.type === 'heavy') {
                    // Heavy shoots 3 bullets
                    for (let i = -1; i <= 1; i++) {
                        const angle = this.angle + (i * 0.2);
                        enemyBullets.push(new EnemyBullet(this.x, this.y, angle, 'heavy'));
                    }
                } else {
                    enemyBullets.push(new EnemyBullet(this.x, this.y, this.angle, this.type));
                }
                playSound(300, 'sawtooth', 0.1);
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle + Math.PI/2 + this.rotation);
                
                // Stealth effect
                if (this.behavior === 'stealth') {
                    ctx.globalAlpha = this.alpha;
                }
                
                // Damage flash effect
                if (Date.now() - this.lastDamageTime < 200) {
                    ctx.filter = 'brightness(2)';
                }
                
                // Motion blur effect for fast movement
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 2) {
                    ctx.shadowBlur = Math.min(speed * 3, 20);
                    ctx.shadowColor = this.color;
                    ctx.shadowOffsetX = -this.vx * 2;
                    ctx.shadowOffsetY = -this.vy * 2;
                }
                
                // Shield effect
                if (this.shieldHealth > 0) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Health bar
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-this.size/2, -this.size - 12, this.size, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-this.size/2, -this.size - 12, (this.health/this.maxHealth) * this.size, 4);
                
                // Body with enhanced details
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 12;
                ctx.shadowColor = this.color;
                
                this.drawBody();
                
                // Draw velocity indicators for debugging (optional)
                if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.vx * 10, this.vy * 10);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            drawBody() {
                switch(this.type) {
                    case 'boss':
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-8, -12, 4, 4);
                        ctx.fillRect(4, -12, 4, 4);
                        ctx.fillRect(-12, -8, 24, 3);
                        ctx.fillRect(-12, 5, 24, 3);
                        break;
                        
                    case 'heavy':
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-6, -10, 3, 3);
                        ctx.fillRect(3, -10, 3, 3);
                        ctx.fillRect(-8, -5, 16, 2);
                        break;
                        
                    case 'shielded':
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size);
                        ctx.lineTo(-this.size/2, this.size/2);
                        ctx.lineTo(this.size/2, this.size/2);
                        ctx.closePath();
                        ctx.fill();
                        // Shield indicators
                        ctx.fillStyle = '#00ffff';
                        ctx.fillRect(-3, -8, 6, 2);
                        break;
                        
                    case 'teleporter':
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#8800ff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                        
                    case 'splitter':
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-1, -this.size/2, 2, this.size);
                        ctx.fillRect(-this.size/2, -1, this.size, 2);
                        break;
                        
                    case 'healer':
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-6, -1, 12, 2);
                        ctx.fillRect(-1, -6, 2, 12);
                        break;
                        
                    case 'charger':
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                        ctx.fillStyle = '#ffffff';
                        for (let i = 0; i < 3; i++) {
                            ctx.fillRect(-8 + i*4, -this.size/2 + i*2, 2, this.size - i*4);
                        }
                        break;
                        
                    default:
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size);
                        ctx.lineTo(-this.size/2, this.size/2);
                        ctx.lineTo(this.size/2, this.size/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-2, -6, 1, 1);
                        ctx.fillRect(1, -6, 1, 1);
                        break;
                }
            }
            
            takeDamage(damage, sourceX = null, sourceY = null) {
                // Check shield first
                if (this.shieldHealth > 0) {
                    this.shieldHealth -= damage;
                    if (this.shieldHealth <= 0) {
                        this.shieldHealth = 0;
                        createParticles(this.x, this.y, '#00ffff', 12);
                        playSound(600, 'sine', 0.2);
                    }
                    // Apply light knockback even through shield
                    if (sourceX !== null && sourceY !== null) {
                        this.applyKnockback(sourceX, sourceY, damage * 0.3);
                    }
                    return false;
                }
                
                this.health -= damage;
                this.lastDamageTime = Date.now();
                createParticles(this.x, this.y, this.color, 8);
                playSound(400, 'square', 0.05);
                
                // Apply knockback effect
                if (sourceX !== null && sourceY !== null) {
                    this.applyKnockback(sourceX, sourceY, damage);
                }
                
                if (this.health <= 0) {
                    // Handle splitter enemy
                    if (this.type === 'splitter' && this.splitCount > 0) {
                        for (let i = 0; i < 2; i++) {
                            const splitEnemy = new Enemy(
                                this.x + (Math.random() - 0.5) * 40,
                                this.y + (Math.random() - 0.5) * 40,
                                'fast'
                            );
                            splitEnemy.health = 2;
                            splitEnemy.size = 8;
                            // Apply splitting momentum
                            splitEnemy.vx = (Math.random() - 0.5) * 4;
                            splitEnemy.vy = (Math.random() - 0.5) * 4;
                            enemies.push(splitEnemy);
                        }
                    }
                    
                    createExplosion(this.x, this.y, this.size * 2);
                    return true;
                }
                return false;
            }
            
            applyKnockback(sourceX, sourceY, force) {
                const dx = this.x - sourceX;
                const dy = this.y - sourceY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const knockback = force * (1 - this.knockbackResistance) / this.mass;
                    this.vx += (dx / dist) * knockback * 2;
                    this.vy += (dy / dist) * knockback * 2;
                    this.angularVelocity += (Math.random() - 0.5) * knockback * 0.5;
                }
            }
        }
        
        class EnemyBullet {
            constructor(x, y, angle, enemyType = 'basic') {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * (enemyType === 'boss' ? 2 : enemyType === 'fast' ? 2.5 : 1.8);
                this.vy = Math.sin(angle) * (enemyType === 'boss' ? 2 : enemyType === 'fast' ? 2.5 : 1.8);
                this.size = enemyType === 'boss' ? 3 : enemyType === 'heavy' ? 2.5 : 2;
                this.life = 100;
                this.damage = enemyType === 'boss' ? 12 : enemyType === 'heavy' ? 10 : 6;
                this.color = enemyType === 'boss' ? '#ff0000' : enemyType === 'heavy' ? '#ff8800' : '#ff4444';
                // Add physics properties
                this.gravity = 0.02;
                this.friction = 0.98;
                this.mass = enemyType === 'boss' ? 3 : enemyType === 'heavy' ? 2 : 1;
            }
            
            update() {
                const speed = bulletTime ? 0.3 : 1;
                
                // Apply physics
                this.vy += this.gravity; // Gravity effect
                this.vx *= this.friction; // Air resistance
                this.vy *= this.friction;
                
                this.x += this.vx * speed;
                this.y += this.vy * speed;
                this.life--;
                
                // Bounce off screen edges with energy loss
                if (this.x <= 0 || this.x >= canvas.width) {
                    this.vx *= -0.6;
                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                }
                if (this.y <= 0 || this.y >= canvas.height) {
                    this.vy *= -0.6;
                    this.y = Math.max(0, Math.min(canvas.height, this.y));
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = 10;
                this.life = 600; // Longer life
                this.bobOffset = Math.random() * Math.PI * 2;
                this.pulseTimer = 0;
            }
            
            update() {
                this.life--;
                this.bobOffset += 0.08;
                this.pulseTimer += 0.1;
                
                // Blink when about to expire
                if (this.life < 120) {
                    this.pulseTimer += 0.2;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y + Math.sin(this.bobOffset) * 5);
                
                const colors = {
                    health: '#ff0080',
                    ammo: '#ffff00',
                    credits: '#00ff80',
                    shield: '#00ffff',
                    damage: '#ff8800'
                };
                
                const alpha = this.life < 120 ? (Math.sin(this.pulseTimer) + 1) * 0.5 : 1;
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = colors[this.type];
                ctx.shadowBlur = 15;
                ctx.shadowColor = colors[this.type];
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Enhanced icons
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                const icons = { 
                    health: '❤️', 
                    ammo: '⚡', 
                    credits: '💰',
                    shield: '🛡️',
                    damage: '💥'
                };
                ctx.fillText(icons[this.type], 0, 5);
                
                ctx.restore();
            }
        }
        
        class Particle {
            constructor(x, y, color, size = null) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 40;
                this.maxLife = 40;
                this.color = color;
                this.size = size || (Math.random() * 4 + 1);
                this.gravity = 0.15;
                this.friction = 0.98;
                this.bounce = 0.6;
                this.spin = (Math.random() - 0.5) * 0.3;
                this.rotation = 0;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.rotation += this.spin;
                this.life--;
                
                // Bounce off screen edges
                if (this.x <= 0 || this.x >= canvas.width) {
                    this.vx *= -this.bounce;
                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                    this.spin *= -1;
                }
                if (this.y >= canvas.height) {
                    this.vy *= -this.bounce;
                    this.y = canvas.height;
                    this.vx *= 0.9; // Ground friction
                    this.spin *= 0.8;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 8;
                ctx.shadowColor = this.color;
                
                // Draw spinning particles with different shapes
                if (this.size > 3) {
                    // Larger particles as squares
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                } else {
                    // Smaller particles as circles
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }
        
        class Explosion {
            constructor(x, y, size = 50) {
                this.x = x;
                this.y = y;
                this.size = 0;
                this.maxSize = size;
                this.life = 30;
                this.maxLife = 30;
                this.rings = [];
                
                // Create multiple rings for better effect
                for (let i = 0; i < 3; i++) {
                    this.rings.push({
                        size: 0,
                        maxSize: size * (1 + i * 0.3),
                        delay: i * 5,
                        life: 30 - i * 5
                    });
                }
            }
            
            update() {
                this.life--;
                this.rings.forEach(ring => {
                    if (ring.delay <= 0) {
                        ring.size += ring.maxSize / 25;
                        ring.life--;
                    } else {
                        ring.delay--;
                    }
                });
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                this.rings.forEach((ring, i) => {
                    if (ring.delay <= 0 && ring.life > 0) {
                        ctx.globalAlpha = ring.life / 30;
                        ctx.fillStyle = i === 0 ? '#ffff00' : i === 1 ? '#ff8800' : '#ff0000';
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, ring.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.restore();
            }
        }
        
        class Hazard {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'laser', 'mine', 'turret'
                this.size = type === 'mine' ? 8 : 15;
                this.life = 300;
                this.timer = 0;
                this.active = false;
            }
            
            update() {
                this.timer++;
                this.life--;
                
                if (this.type === 'laser' && this.timer % 120 === 0) {
                    this.active = true;
                    // Create laser beam
                    lasers.push(new Laser(this.x, this.y, Math.atan2(player.y - this.y, player.x - this.x)));
                }
                
                if (this.type === 'mine' && distance(this, player) < 50) {
                    this.active = true;
                    explosions.push(new Explosion(this.x, this.y, 80));
                    return false;
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.type === 'laser') {
                    ctx.fillStyle = this.active ? '#ff0000' : '#ff4444';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff0000';
                } else if (this.type === 'mine') {
                    ctx.fillStyle = '#ff8800';
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff8800';
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.type === 'laser') {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
                this.active = false;
            }
        }
        
        class Barrier {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 20;
                this.health = 10;
                this.maxHealth = 10;
                this.destructible = true;
            }
            
            update() {
                return this.health > 0;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = '#444444';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Health indicator
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2 - 8, this.width, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2 - 8, (this.health/this.maxHealth) * this.width, 4);
                
                ctx.restore();
            }
            
            takeDamage(damage) {
                this.health -= damage;
                createParticles(this.x, this.y, '#888888', 5);
                if (this.health <= 0) {
                    player.barriersDestroyed++;
                    if (player.barriersDestroyed >= 20) {
                        checkAchievement('barrierBreaker');
                    }
                    return true;
                }
                return false;
            }
        }
        
        class Drone {
            constructor(x, y, owner = 'player') {
                this.x = x;
                this.y = y;
                this.owner = owner;
                this.size = 8;
                this.speed = 3;
                this.health = 5;
                this.shootTimer = 0;
                this.life = 600; // 10 seconds
                this.target = null;
                this.angle = 0;
                this.orbitRadius = 50;
                this.orbitAngle = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.life--;
                
                if (this.owner === 'player') {
                    // Orbit around player
                    this.orbitAngle += 0.05;
                    this.x = player.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                    this.y = player.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                    
                    // Find nearest enemy
                    let nearest = null;
                    let nearestDist = Infinity;
                    enemies.forEach(enemy => {
                        const dist = distance(this, enemy);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = enemy;
                        }
                    });
                    
                    if (nearest && nearestDist < 150) {
                        this.target = nearest;
                        this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                        
                        this.shootTimer++;
                        if (this.shootTimer > 30) {
                            bullets.push(new Bullet(this.x, this.y, this.angle, weapons.blaster));
                            this.shootTimer = 0;
                            playSound(500, 'sine', 0.05);
                        }
                    }
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.owner === 'player' ? '#00ffff' : '#ff0080';
                ctx.shadowBlur = 8;
                ctx.shadowColor = ctx.fillStyle;
                
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(-this.size/2, this.size/2);
                ctx.lineTo(this.size/2, this.size/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        class Meteor {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20 + Math.random() * 20;
                this.speed = 2 + Math.random() * 3;
                this.angle = Math.random() * Math.PI * 2;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.health = Math.floor(this.size / 5);
                this.maxHealth = this.health;
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.rotation += this.rotationSpeed;
                
                // Bounce off screen edges
                if (this.x < 0 || this.x > canvas.width) this.angle = Math.PI - this.angle;
                if (this.y < 0 || this.y > canvas.height) this.angle = -this.angle;
                
                return this.health > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.fillStyle = '#8B4513';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#8B4513';
                
                // Draw irregular meteor shape
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = this.size * (0.8 + Math.sin(angle * 3) * 0.2);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            takeDamage(damage) {
                this.health -= damage;
                createParticles(this.x, this.y, '#8B4513', 8);
                if (this.health <= 0) {
                    createExplosion(this.x, this.y, this.size);
                    player.meteorsDestroyed++;
                    if (player.meteorsDestroyed >= 10) {
                        checkAchievement('meteorDestroyer');
                    }
                    return true;
                }
                return false;
            }
        }
        
        class Wormhole {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 25;
                this.life = 1200; // 20 seconds
                this.rotation = 0;
                this.partner = null;
                this.cooldown = 0;
            }
            
            update() {
                this.life--;
                this.rotation += 0.1;
                if (this.cooldown > 0) this.cooldown--;
                
                // Check if player is close
                if (distance(this, player) < this.size && this.cooldown === 0 && this.partner) {
                    player.x = this.partner.x;
                    player.y = this.partner.y;
                    this.cooldown = 60;
                    this.partner.cooldown = 60;
                    player.wormholeUses++;
                    if (player.wormholeUses >= 5) {
                        checkAchievement('wormholeExplorer');
                    }
                    createParticles(this.x, this.y, '#8800ff', 20);
                    createParticles(this.partner.x, this.partner.y, '#8800ff', 20);
                    playSound(800, 'sine', 0.3);
                }
                
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw swirling wormhole
                for (let i = 0; i < 5; i++) {
                    ctx.globalAlpha = 0.3 - i * 0.05;
                    ctx.strokeStyle = '#8800ff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size - i * 4, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        class SpecialEvent {
            constructor(type) {
                this.type = type;
                this.timer = 0;
                this.duration = 600; // 10 seconds
                this.announced = false;
            }
            
            update() {
                this.timer++;
                
                if (!this.announced) {
                    this.announce();
                    this.announced = true;
                }
                
                switch(this.type) {
                    case 'meteor_shower':
                        if (this.timer % 30 === 0) {
                            const x = Math.random() * canvas.width;
                            const y = -50;
                            meteors.push(new Meteor(x, y));
                        }
                        break;
                        
                    case 'enemy_reinforcements':
                        if (this.timer % 60 === 0) {
                            spawnEnemies(2);
                        }
                        break;
                        
                    case 'power_surge':
                        // Increase weapon damage temporarily
                        break;
                        
                    case 'gravity_well':
                        // Pull all objects toward center
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const pullForce = 0.5;
                        
                        enemies.forEach(enemy => {
                            const dx = centerX - enemy.x;
                            const dy = centerY - enemy.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 0) {
                                enemy.x += (dx / dist) * pullForce;
                                enemy.y += (dy / dist) * pullForce;
                            }
                        });
                        break;
                }
                
                return this.timer < this.duration;
            }
            
            announce() {
                const messages = {
                    meteor_shower: 'METEOR SHOWER INCOMING!',
                    enemy_reinforcements: 'ENEMY REINFORCEMENTS!',
                    power_surge: 'POWER SURGE ACTIVATED!',
                    gravity_well: 'GRAVITY WELL DETECTED!'
                };
                showNotification(messages[this.type]);
                playSound(400, 'sawtooth', 0.5);
            }
        }
        
        // Utility functions
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, color));
            }
        }
        
        function createExplosion(x, y, size) {
            explosions.push(new Explosion(x, y, size));
            playSound(150, 'sawtooth', 0.3);
            if (gameSettings.screenShakeEnabled) {
                screenShake = 10;
            }
        }
        
        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }
        
        function addExperience(amount) {
            experience += amount;
            if (experience >= nextLevelXP) {
                level++;
                experience -= nextLevelXP;
                nextLevelXP = Math.floor(nextLevelXP * 1.5);
                showNotification(`Level Up! Level ${level}`);
                playSound(600, 'sine', 0.5);
                
                // Level up bonuses
                player.maxHealth += 10;
                player.health = Math.min(player.maxHealth, player.health + 50);
                credits += 100;
            }
        }
        
        function checkAchievement(key) {
            if (!achievements[key].unlocked) {
                achievements[key].unlocked = true;
                showAchievement(achievements[key]);
                playSound(800, 'sine', 0.3);
            }
        }
        
        function showAchievement(achievement) {
            const div = document.createElement('div');
            div.className = 'achievement';
            div.innerHTML = `<strong>${achievement.name}</strong><br>${achievement.description}`;
            document.getElementById('achievementList').appendChild(div);
            
            setTimeout(() => {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
            }, 5000);
        }
        
        // Enhanced Mission System
        function generateMissions() {
            const availableMissions = [];
            
            missionTypes.forEach(missionType => {
                if (availableMissions.length < 3) {
                    const mission = createMissionFromType(missionType);
                    availableMissions.push(mission);
                }
            });
            
            return availableMissions;
        }
        
        function createMissionFromType(type) {
            const mission = { ...type };
            mission.id = Date.now() + Math.random();
            mission.progress = 0;
            mission.active = false;
            
            switch(type.id) {
                case 'killStreak':
                    mission.target = 10 + Math.floor(wave / 3) * 5;
                    mission.description = mission.description.replace('{target}', mission.target);
                    break;
                case 'waveSpeed':
                    mission.target = Math.max(30, 90 - wave * 2);
                    mission.description = mission.description.replace('{target}', mission.target);
                    break;
                case 'weaponMaster':
                    const weaponList = Object.keys(weapons);
                    mission.weapon = weaponList[Math.floor(Math.random() * weaponList.length)];
                    mission.target = 15 + Math.floor(wave / 2) * 3;
                    mission.description = mission.description.replace('{target}', mission.target).replace('{weapon}', weapons[mission.weapon].name);
                    break;
                case 'abilityMaster':
                    const abilities = ['shield', 'dash', 'bomb', 'time', 'heal'];
                    mission.ability = abilities[Math.floor(Math.random() * abilities.length)];
                    mission.target = 5 + Math.floor(wave / 4);
                    mission.description = mission.description.replace('{target}', mission.target).replace('{ability}', mission.ability);
                    break;
            }
            
            return mission;
        }
        
        function updateMissions() {
            activeMissions.forEach(mission => {
                switch(mission.id) {
                    case 'killStreak':
                        mission.progress = player.killStreak;
                        break;
                    case 'weaponMaster':
                        mission.progress = weaponKills[mission.weapon] || 0;
                        break;
                }
                
                if (mission.progress >= mission.target) {
                    completeMission(mission);
                }
            });
        }
        
        function completeMission(mission) {
            credits += mission.reward;
            experience += mission.reward / 5;
            completedMissions.push(mission);
            activeMissions = activeMissions.filter(m => m.id !== mission.id);
            showNotification(`Mission Complete: ${mission.name} (+${mission.reward} credits)`);
            playSound(800, 'sine', 0.5);
        }
        
        // Dynamic Difficulty System
        function updateDifficulty() {
            // Base difficulty on wave, player performance, and time
            const waveDifficulty = wave * 0.1;
            const performanceDifficulty = (player.killStreak / 10) * 0.05;
            const timeDifficulty = (survivalTime / 3600) * 0.02; // per minute
            
            difficulty = 1 + waveDifficulty + performanceDifficulty + timeDifficulty;
            
            // Environmental hazard scaling
            environmentHazardLevel = Math.min(difficulty * 0.3, 2.0);
            
            // Game speed scaling for bullet time effectiveness
            gameSpeed = Math.min(1 + difficulty * 0.1, 1.5);
            
            // Economy balancing
            economyMultiplier = 1 + (difficulty - 1) * 0.2;
        }
        
        // Enhanced Enemy Spawning with AI
        function spawnEnemies(additionalCount = 0) {
            const baseCount = Math.min(wave + 3 + additionalCount, 30);
            const enemyCount = Math.floor(baseCount * difficulty);
            
            // Formation spawning for advanced waves
            if (wave >= 10 && Math.random() < 0.3) {
                spawnFormation();
            } else {
                spawnRandomEnemies(enemyCount);
            }
            
            // Spawn environmental elements
            spawnEnvironmentalElements();
            
            // Spawn environmental elements
            spawnEnvironmentalElements();
        }
        
        function spawnFormation() {
            const formations = ['line', 'circle', 'wedge', 'swarm'];
            const formation = formations[Math.floor(Math.random() * formations.length)];
            const centerX = Math.random() * canvas.width;
            const centerY = -100;
            
            switch(formation) {
                case 'line':
                    for (let i = 0; i < 5; i++) {
                        const enemy = new Enemy(centerX + (i - 2) * 60, centerY, getWeightedEnemyType());
                        enemy.formation = 'line';
                        enemies.push(enemy);
                    }
                    break;
                case 'circle':
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const enemy = new Enemy(
                            centerX + Math.cos(angle) * 80,
                            centerY + Math.sin(angle) * 80,
                            getWeightedEnemyType()
                        );
                        enemy.formation = 'circle';
                        enemies.push(enemy);
                    }
                    break;
                case 'wedge':
                    // Leader in front
                    enemies.push(new Enemy(centerX, centerY, 'commander'));
                    // Flankers
                    for (let i = 1; i <= 3; i++) {
                        enemies.push(new Enemy(centerX - i * 40, centerY + i * 30, getWeightedEnemyType()));
                        enemies.push(new Enemy(centerX + i * 40, centerY + i * 30, getWeightedEnemyType()));
                    }
                    break;
                case 'swarm':
                    for (let i = 0; i < 8; i++) {
                        const enemy = new Enemy(
                            centerX + (Math.random() - 0.5) * 200,
                            centerY + (Math.random() - 0.5) * 100,
                            Math.random() < 0.7 ? 'fast' : 'basic'
                        );
                        enemy.formation = 'swarm';
                        enemies.push(enemy);
                    }
                    break;
            }
        }
        
        function spawnRandomEnemies(count) {
            for (let i = 0; i < count; i++) {
                let x, y;
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: x = Math.random() * canvas.width; y = -50; break;
                    case 1: x = canvas.width + 50; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = canvas.height + 50; break;
                    case 3: x = -50; y = Math.random() * canvas.height; break;
                }
                
                const enemyType = getWeightedEnemyType();
                const enemy = new Enemy(x, y, enemyType);
                
                // Apply difficulty scaling
                enemy.health = Math.floor(enemy.health * difficulty);
                enemy.maxHealth = enemy.health;
                enemy.speed *= (1 + (difficulty - 1) * 0.2);
                enemy.rank = Math.floor(difficulty / 2);
                
                enemies.push(enemy);
            }
        }
        
        function getWeightedEnemyType() {
            const weights = {
                'basic': 40 - Math.min(wave, 30),
                'fast': wave >= 3 ? 20 : 0,
                'heavy': wave >= 5 ? 15 : 0,
                'shielded': wave >= 6 ? 10 : 0,
                'teleporter': wave >= 8 ? 8 : 0,
                'splitter': wave >= 10 ? 8 : 0,
                'healer': wave >= 12 ? 5 : 0,
                'charger': wave >= 15 ? 5 : 0,
                'stealth': wave >= 18 ? 3 : 0,
                'commander': wave >= 10 ? 2 : 0,
                'sniper': wave >= 12 ? 3 : 0,
                'flanker': wave >= 14 ? 4 : 0,
                'berserker': wave >= 16 ? 3 : 0,
                'support': wave >= 18 ? 2 : 0,
                'adaptive': wave >= 20 ? 2 : 0,
                'boss': (wave >= 8 && wave % 5 === 0) ? 1 : 0
            };
            
            const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (const [type, weight] of Object.entries(weights)) {
                random -= weight;
                if (random <= 0) return type;
            }
            
            return 'basic';
        }
        
        function spawnEnvironmentalElements() {
            // Spawn various environmental elements
            if (wave >= 3 && Math.random() < 0.3) {
                const hazardX = Math.random() * canvas.width;
                const hazardY = Math.random() * canvas.height;
                const hazardType = Math.random() < 0.5 ? 'laser' : 'mine';
                hazards.push(new Hazard(hazardX, hazardY, hazardType));
            }
            
            // Spawn barriers
            if (wave >= 4 && Math.random() < 0.4) {
                for (let i = 0; i < 2; i++) {
                    barriers.push(new Barrier(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height
                    ));
                }
            }
            
            // Spawn meteors
            if (wave >= 6 && Math.random() < 0.2) {
                meteors.push(new Meteor(
                    Math.random() * canvas.width,
                    -50
                ));
            }
            
            // Spawn wormholes in pairs
            if (wave >= 7 && Math.random() < 0.15) {
                const wormhole1 = new Wormhole(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                );
                const wormhole2 = new Wormhole(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                );
                wormhole1.partner = wormhole2;
                wormhole2.partner = wormhole1;
                wormholes.push(wormhole1, wormhole2);
            }
            
            // Spawn special events
            if (wave >= 5 && Math.random() < 0.1) {
                const eventTypes = ['meteor_shower', 'enemy_reinforcements', 'power_surge', 'gravity_well'];
                const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                specialEvents.push(new SpecialEvent(eventType));
            }
        }
        
        function spawnPowerup(x, y) {
            if (Math.random() < 0.4) {
                const types = ['health', 'ammo', 'credits', 'shield', 'damage'];
                const weights = [0.3, 0.25, 0.2, 0.15, 0.1];
                
                let random = Math.random();
                let type = types[0];
                for (let i = 0; i < types.length; i++) {
                    if (random < weights[i]) {
                        type = types[i];
                        break;
                    }
                    random -= weights[i];
                }
                
                powerups.push(new Powerup(x, y, type));
            }
        }
        
        function updatePlayer() {
            const speed = player.speed * (1 + upgrades.speed * 0.3) * (bulletTime ? 1.5 : 1);
            
            // Movement
            if (keys['w'] || keys['W']) player.y -= speed;
            if (keys['s'] || keys['S']) player.y += speed;
            if (keys['a'] || keys['A']) player.x -= speed;
            if (keys['d'] || keys['D']) player.x += speed;
            
            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            
            // Aim at mouse
            player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
            
            // Update timers
            if (player.shieldTimer > 0) {
                player.shieldTimer--;
                if (player.shieldTimer === 0) player.shield = false;
            }
            
            if (player.dashCooldown > 0) player.dashCooldown--;
            
            if (player.invulnerableTimer > 0) {
                player.invulnerableTimer--;
                if (player.invulnerableTimer === 0) player.invulnerable = false;
            }
            
            // Health regeneration
            if (upgrades.regen > 0) {
                player.regenTimer++;
                if (player.regenTimer >= 60) { // Every second
                    player.health = Math.min(player.maxHealth, player.health + upgrades.regen);
                    player.regenTimer = 0;
                }
            }
            
            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    combo = 0;
                    document.getElementById('comboCounter').style.display = 'none';
                }
            }
        }
        
        function shoot() {
            const weapon = weapons[player.currentWeapon];
            const now = Date.now();
            
            // Handle charging weapons
            if (weapon.charge) {
                if (mouse.down && !player.charging) {
                    player.charging = true;
                    player.chargeTime = 0;
                } else if (player.charging && mouse.down) {
                    player.chargeTime++;
                    if (player.chargeTime % 10 === 0) {
                        createParticles(player.x, player.y, weapon.color, 2);
                    }
                    return;
                } else if (player.charging && !mouse.down) {
                    player.charging = false;
                    if (player.chargeTime > 30 && player.ammo > 0) {
                        const chargeDamage = Math.min(player.chargeTime / 10, 20);
                        const chargedWeapon = {...weapon, damage: chargeDamage};
                        bullets.push(new Bullet(player.x, player.y, player.angle, chargedWeapon));
                        player.ammo--;
                        player.lastShot = now;
                        createParticles(player.x, player.y, weapon.color, 15);
                        playSound(1200, 'sine', 0.3);
                        updateHUD();
                    }
                    player.chargeTime = 0;
                }
                return;
            }
            
            if (player.ammo > 0 && !player.reloading && now - player.lastShot > weapon.fireRate) {
                if (weapon.name === 'Shotgun') {
                    for (let i = 0; i < 6; i++) {
                        bullets.push(new Bullet(player.x, player.y, player.angle, weapon));
                    }
                } else if (weapon.name === 'Laser') {
                    lasers.push(new Laser(player.x, player.y, player.angle));
                } else if (weapon.name === 'Rocket') {
                    bullets.push(new Bullet(player.x, player.y, player.angle, weapon));
                } else if (weapon.name === 'Flamethrower') {
                    // Flame particles
                    for (let i = 0; i < 3; i++) {
                        const flameBullet = new Bullet(player.x, player.y, player.angle, weapon);
                        flameBullet.life = 30; // Shorter range
                        bullets.push(flameBullet);
                    }
                } else {
                    bullets.push(new Bullet(player.x, player.y, player.angle, weapon));
                }
                
                player.ammo--;
                player.lastShot = now;
                createParticles(player.x, player.y, weapon.color, 5);
                playSound(weapon.name === 'Laser' ? 800 : weapon.name === 'Rocket' ? 200 : weapon.name === 'Flamethrower' ? 300 : 400, 'square', 0.1);
                updateHUD();
            }
        }
        
        function reload() {
            if (player.ammo < weapons[player.currentWeapon].ammo && !player.reloading) {
                player.reloading = true;
                showNotification('RELOADING...');
                playSound(300, 'sawtooth', 0.2);
                setTimeout(() => {
                    player.ammo = weapons[player.currentWeapon].ammo;
                    player.reloading = false;
                    updateHUD();
                }, 2000);
            }
        }
        
        function switchWeapon(weaponKey) {
            const weaponMap = { '1': 'blaster', '2': 'rifle', '3': 'shotgun', '4': 'plasma', '5': 'laser', '6': 'rocket' };
            const newWeapon = weaponMap[weaponKey];
            
            if (newWeapon && upgrades.weapons.includes(newWeapon)) {
                player.currentWeapon = newWeapon;
                player.ammo = weapons[newWeapon].ammo;
                updateHUD();
                showNotification(`Weapon: ${weapons[newWeapon].name}`);
                playSound(500, 'sine', 0.1);
            }
        }
        
        function useAbility(ability) {
            if (abilities[ability].cooldown > 0) return;
            
            switch(ability) {
                case 'shield':
                    player.shield = true;
                    player.shieldTimer = 300;
                    abilities.shield.cooldown = abilities.shield.maxCooldown;
                    showNotification('Energy Shield Activated!');
                    playSound(600, 'sine', 0.3);
                    break;
                    
                case 'dash':
                    const dashDistance = 120;
                    const newX = player.x + Math.cos(player.angle) * dashDistance;
                    const newY = player.y + Math.sin(player.angle) * dashDistance;
                    player.x = Math.max(player.size, Math.min(canvas.width - player.size, newX));
                    player.y = Math.max(player.size, Math.min(canvas.height - player.size, newY));
                    player.invulnerable = true;
                    player.invulnerableTimer = 30;
                    abilities.dash.cooldown = abilities.dash.maxCooldown;
                    createParticles(player.x, player.y, '#00ffff', 15);
                    showNotification('Cyber Dash!');
                    playSound(1000, 'sine', 0.2);
                    break;
                    
                case 'bomb':
                    explosions.push(new Explosion(player.x, player.y, 200));
                    enemies.forEach(enemy => {
                        if (distance(player, enemy) < 200) {
                            enemy.takeDamage(8);
                        }
                    });
                    abilities.bomb.cooldown = abilities.bomb.maxCooldown;
                    showNotification('EMP Detonated!');
                    playSound(100, 'sawtooth', 0.5);
                    screenShake = 15;
                    break;
                    
                case 'time':
                    bulletTime = true;
                    bulletTimeTimer = 360;
                    abilities.time.cooldown = abilities.time.maxCooldown;
                    showNotification('Bullet Time Activated!');
                    playSound(1200, 'sine', 0.4);
                    break;
                    
                case 'heal':
                    player.health = Math.min(player.maxHealth, player.health + 50);
                    abilities.heal.cooldown = abilities.heal.maxCooldown;
                    showNotification('Nano Heal Activated!');
                    playSound(700, 'sine', 0.3);
                    createParticles(player.x, player.y, '#00ff00', 10);
                    break;
            }
        }
        
        function updateHUD() {
            // Safely update elements with null checks
            const safeUpdate = (id, value) => {
                const element = document.getElementById(id);
                if (element) element.textContent = value;
            };
            
            const safeUpdateStyle = (id, property, value) => {
                const element = document.getElementById(id);
                if (element) element.style[property] = value;
            };
            
            safeUpdate('score', score);
            safeUpdate('level', level);
            safeUpdate('experience', experience);
            safeUpdate('nextLevel', nextLevelXP);
            safeUpdate('healthValue', Math.floor(player.health));
            safeUpdate('maxHealthValue', player.maxHealth);
            safeUpdate('ammoValue', player.reloading ? 'RELOADING...' : player.ammo);
            safeUpdate('maxAmmoValue', weapons[player.currentWeapon].ammo);
            safeUpdate('weaponName', weapons[player.currentWeapon].name);
            safeUpdate('creditsValue', credits);
            safeUpdate('wave', wave);
            safeUpdate('kills', kills);
            safeUpdate('combo', combo);
            
            // Update progress bars
            const healthPercent = (player.health / player.maxHealth) * 100;
            const expPercent = (experience / nextLevelXP) * 100;
            safeUpdateStyle('healthFill', 'width', healthPercent + '%');
            safeUpdateStyle('expFill', 'width', expPercent + '%');
            
            // Update ability cooldowns
            for (let ability in abilities) {
                const element = document.getElementById(ability);
                if (element) {
                    const cooldownText = element.querySelector('.cooldown-text');
                    if (abilities[ability].cooldown > 0) {
                        element.classList.add('cooldown');
                        element.style.opacity = 0.5;
                        if (cooldownText) {
                            cooldownText.textContent = Math.ceil(abilities[ability].cooldown / 1000) + 's';
                        }
                    } else {
                        element.classList.remove('cooldown');
                        element.style.opacity = 1;
                        if (cooldownText) {
                            cooldownText.textContent = '';
                        }
                    }
                }
            }
            
            // Update shop levels with safe updates
            safeUpdate('healthLevel', upgrades.health);
            safeUpdate('damageLevel', upgrades.damage);
            safeUpdate('speedLevel', upgrades.speed);
            safeUpdate('armorLevel', upgrades.armor || 0);
            safeUpdate('criticalChanceLevel', upgrades.criticalChance || 0);
            safeUpdate('energyEfficiencyLevel', upgrades.energyEfficiency || 0);
            safeUpdate('shieldCapacityLevel', upgrades.shieldCapacity || 0);
            safeUpdate('magneticRadiusLevel', upgrades.magneticRadius || 0);
            safeUpdate('luckLevel', upgrades.luck || 0);
            safeUpdate('regenLevel', upgrades.regen || 0);
            
            // Update cost displays
            safeUpdate('healthCost', 500 + (upgrades.health * 250));
            safeUpdate('damageCost', 750 + (upgrades.damage * 500));
            safeUpdate('speedCost', 600 + (upgrades.speed * 400));
            safeUpdate('armorCost', 800 + ((upgrades.armor || 0) * 600));
            safeUpdate('criticalChanceCost', 900 + ((upgrades.criticalChance || 0) * 700));
            safeUpdate('energyEfficiencyCost', 700 + ((upgrades.energyEfficiency || 0) * 500));
            safeUpdate('shieldCapacityCost', 1200 + ((upgrades.shieldCapacity || 0) * 800));
            safeUpdate('magneticRadiusCost', 800 + ((upgrades.magneticRadius || 0) * 600));
            safeUpdate('luckCost', 1500 + ((upgrades.luck || 0) * 1000));
            safeUpdate('regenCost', 1200 + ((upgrades.regen || 0) * 800));
            
            // Update progress bars for upgrades
            const updateProgressBar = (id, level, maxLevel) => {
                const progressBar = document.getElementById(id);
                if (progressBar) {
                    const percent = (level / maxLevel) * 100;
                    progressBar.style.width = percent + '%';
                }
            };
            
            updateProgressBar('healthProgress', upgrades.health, 10);
            updateProgressBar('damageProgress', upgrades.damage, 5);
            updateProgressBar('speedProgress', upgrades.speed, 5);
            updateProgressBar('armorProgress', upgrades.armor || 0, 8);
            updateProgressBar('criticalChanceProgress', upgrades.criticalChance || 0, 10);
            updateProgressBar('energyEfficiencyProgress', upgrades.energyEfficiency || 0, 5);
            updateProgressBar('regenProgress', upgrades.regen || 0, 3);
        }
        
        function updateMinimap() {
            minimapCtx.clearRect(0, 0, 150, 150);
            
            minimapCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
            minimapCtx.fillRect(0, 0, 150, 150);
            
            const scaleX = 150 / canvas.width;
            const scaleY = 150 / canvas.height;
            
            // Draw player
            minimapCtx.fillStyle = player.shield ? '#ffffff' : '#00ffff';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scaleX, player.y * scaleY, 4, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw enemies
            enemies.forEach(enemy => {
                minimapCtx.fillStyle = enemy.type === 'boss' ? '#ff0000' : '#ff0080';
                minimapCtx.beginPath();
                minimapCtx.arc(enemy.x * scaleX, enemy.y * scaleY, enemy.type === 'boss' ? 4 : 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            // Draw powerups
            powerups.forEach(powerup => {
                minimapCtx.fillStyle = '#ffff00';
                minimapCtx.beginPath();
                minimapCtx.arc(powerup.x * scaleX, powerup.y * scaleY, 1, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            // Draw hazards
            hazards.forEach(hazard => {
                minimapCtx.fillStyle = '#ff4444';
                minimapCtx.beginPath();
                minimapCtx.arc(hazard.x * scaleX, hazard.y * scaleY, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
        }
        
        function checkCollisions() {
            // Track multi-kills
            let killsThisFrame = 0;
            
            // Player bullets vs enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                let bulletDestroyed = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (distance(bullets[i], enemies[j]) < bullets[i].size + enemies[j].size) {
                        const enemy = enemies[j];
                        if (enemy.takeDamage(bullets[i].damage, bullets[i].x, bullets[i].y)) {
                            score += enemy.type === 'boss' ? 1000 : enemy.type === 'heavy' ? 300 : enemy.type === 'fast' ? 75 : 150;
                            credits += enemy.credits;
                            kills++;
                            killsThisFrame++;
                            addExperience(enemy.xp);
                            
                            // Combo system
                            combo++;
                            comboTimer = 180; // 3 seconds
                            if (combo > maxCombo) maxCombo = combo;
                            
                            if (combo >= 5) {
                                document.getElementById('comboCounter').style.display = 'block';
                                document.getElementById('comboValue').textContent = combo;
                                score += combo * 10; // Bonus points
                            }
                            
                            // Achievement checks
                            if (kills === 1) checkAchievement('firstKill');
                            if (kills === 100) checkAchievement('kills100');
                            if (kills === 500) checkAchievement('kills500');
                            if (enemy.type === 'boss') checkAchievement('bossKiller');
                            if (combo >= 10) checkAchievement('combo10');
                            if (combo >= 25) checkAchievement('combo25');
                            
                            spawnPowerup(enemy.x, enemy.y);
                            enemies.splice(j, 1);
                            
                            // Rocket explosion
                            if (bullets[i].explosive) {
                                createExplosion(bullets[i].x, bullets[i].y, 60);
                                // Damage nearby enemies
                                enemies.forEach(nearbyEnemy => {
                                    if (distance(bullets[i], nearbyEnemy) < 60) {
                                        nearbyEnemy.takeDamage(bullets[i].damage);
                                    }
                                });
                            }
                        }
                        
                        if (!bullets[i].piercing) {
                            bullets.splice(i, 1);
                            bulletDestroyed = true;
                        } else {
                            bullets[i].hits++;
                            if (bullets[i].hits >= 3) {
                                bullets.splice(i, 1);
                                bulletDestroyed = true;
                            }
                        }
                        break;
                    }
                }
                if (bulletDestroyed) continue;
                
                // Bullets vs barriers
                for (let j = barriers.length - 1; j >= 0; j--) {
                    const barrier = barriers[j];
                    if (bullets[i].x > barrier.x - barrier.width/2 && 
                        bullets[i].x < barrier.x + barrier.width/2 &&
                        bullets[i].y > barrier.y - barrier.height/2 && 
                        bullets[i].y < barrier.y + barrier.height/2) {
                        
                        if (barrier.takeDamage(bullets[i].damage)) {
                            barriers.splice(j, 1);
                        }
                        
                        if (!bullets[i].piercing) {
                            bullets.splice(i, 1);
                            bulletDestroyed = true;
                        }
                        break;
                    }
                }
                if (bulletDestroyed) continue;
                
                // Bullets vs meteors
                for (let j = meteors.length - 1; j >= 0; j--) {
                    if (distance(bullets[i], meteors[j]) < bullets[i].size + meteors[j].size) {
                        if (meteors[j].takeDamage(bullets[i].damage)) {
                            score += 200;
                            credits += 75;
                            meteors.splice(j, 1);
                        }
                        
                        if (!bullets[i].piercing) {
                            bullets.splice(i, 1);
                            bulletDestroyed = true;
                        }
                        break;
                    }
                }
                if (bulletDestroyed) continue;
            }
            
            // Multi-kill achievement
            if (killsThisFrame >= 5) {
                multiKillTimer = 60; // 1 second window
            }
            if (multiKillTimer > 0) {
                multiKillTimer--;
                if (multiKillTimer === 0) {
                    checkAchievement('multiKill');
                }
            }
            
            // Laser vs enemies
            for (let i = lasers.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const laser = lasers[i];
                    const enemy = enemies[j];
                    
                    // Line-circle collision detection
                    const dx = enemy.x - laser.x;
                    const dy = enemy.y - laser.y;
                    const laserDx = Math.cos(laser.angle) * laser.length;
                    const laserDy = Math.sin(laser.angle) * laser.length;
                    
                    const dot = (dx * laserDx + dy * laserDy) / (laser.length * laser.length);
                    const closestX = laser.x + dot * laserDx;
                    const closestY = laser.y + dot * laserDy;
                    
                    if (distance({x: closestX, y: closestY}, enemy) < enemy.size + 5) {
                        if (enemy.takeDamage(laser.damage)) {
                            score += enemy.type === 'boss' ? 1000 : enemy.type === 'heavy' ? 300 : 150;
                            credits += enemy.credits;
                            kills++;
                            addExperience(enemy.xp);
                            spawnPowerup(enemy.x, enemy.y);
                            enemies.splice(j, 1);
                        }
                    }
                }
            }
            
            // Enemy bullets vs player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (distance(enemyBullets[i], player) < enemyBullets[i].size + player.size) {
                    if (!player.shield && !player.invulnerable) {
                        player.health -= enemyBullets[i].damage;
                        createParticles(player.x, player.y, '#ff0080', 12);
                        playSound(200, 'sawtooth', 0.2);
                        screenShake = 8;
                        combo = 0; // Reset combo on hit
                        comboTimer = 0;
                        document.getElementById('comboCounter').style.display = 'none';
                    } else {
                        createParticles(player.x, player.y, '#00ffff', 8);
                        playSound(600, 'sine', 0.1);
                    }
                    enemyBullets.splice(i, 1);
                    
                    if (player.health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalKills').textContent = kills;
                        document.getElementById('finalWaves').textContent = wave;
                        document.getElementById('maxCombo').textContent = maxCombo;
                        document.getElementById('finalLevel').textContent = level;
                        gameOverScreen.style.display = 'flex';
                        playSound(100, 'sawtooth', 1);
                    }
                }
            }
            
            // Enemies vs player
            for (let enemy of enemies) {
                if (distance(enemy, player) < enemy.size + player.size) {
                    if (!player.shield && !player.invulnerable) {
                        player.health -= 8;
                        createParticles(player.x, player.y, '#ff0080', 10);
                        playSound(150, 'sawtooth', 0.3);
                        screenShake = 12;
                        combo = 0;
                        comboTimer = 0;
                        document.getElementById('comboCounter').style.display = 'none';
                    }
                    
                    if (player.health <= 0) {
                        gameState = 'gameOver';
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('finalKills').textContent = kills;
                        document.getElementById('finalWaves').textContent = wave;
                        document.getElementById('maxCombo').textContent = maxCombo;
                        document.getElementById('finalLevel').textContent = level;
                        gameOverScreen.style.display = 'flex';
                        playSound(100, 'sawtooth', 1);
                    }
                }
            }
            
            // Player vs powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (distance(player, powerups[i]) < player.size + powerups[i].size) {
                    const powerup = powerups[i];
                    switch(powerup.type) {
                        case 'health':
                            player.health = Math.min(player.maxHealth, player.health + 30);
                            showNotification('+30 Health');
                            break;
                        case 'ammo':
                            player.ammo = weapons[player.currentWeapon].ammo;
                            showNotification('Ammo Refilled');
                            break;
                        case 'credits':
                            credits += 150;
                            showNotification('+150 Credits');
                            break;
                        case 'shield':
                            player.shield = true;
                            player.shieldTimer = 300;
                            showNotification('Temporary Shield!');
                            break;
                        case 'damage':
                            // Temporary damage boost
                            showNotification('Damage Boost!');
                            break;
                        case 'drone':
                            if (drones.length < 5) {
                                drones.push(new Drone(player.x, player.y, 'player'));
                                showNotification('Drone Deployed!');
                            }
                            break;
                        case 'repair':
                            barriers.forEach(barrier => {
                                barrier.health = barrier.maxHealth;
                            });
                            showNotification('Barriers Repaired!');
                            break;
                        case 'weapon':
                            const availableWeapons = ['flamethrower', 'railgun'];
                            const randomWeapon = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                            if (!upgrades.weapons.includes(randomWeapon)) {
                                upgrades.weapons.push(randomWeapon);
                                showNotification(`${weapons[randomWeapon].name} Unlocked!`);
                            }
                            break;
                    }
                    powerups.splice(i, 1);
                    playSound(500, 'sine', 0.2);
                }
            }
            
            // Hazards vs player
            for (let i = hazards.length - 1; i >= 0; i--) {
                if (distance(player, hazards[i]) < player.size + hazards[i].size) {
                    if (!player.shield && !player.invulnerable) {
                        player.health -= 25;
                        createParticles(player.x, player.y, '#ff8800', 15);
                        playSound(100, 'sawtooth', 0.4);
                        screenShake = 20;
                    }
                    hazards.splice(i, 1);
                }
            }
        }
        
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle + Math.PI/2);
            
            // Invulnerability effect
            if (player.invulnerable) {
                ctx.globalAlpha = 0.5;
            }
            
            // Shield effect
            if (player.shield) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.arc(0, 0, player.size + 12, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Enhanced ship design
            ctx.fillStyle = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(0, -player.size);
            ctx.lineTo(-player.size/2, player.size/2);
            ctx.lineTo(-player.size/4, player.size/4);
            ctx.lineTo(player.size/4, player.size/4);
            ctx.lineTo(player.size/2, player.size/2);
            ctx.closePath();
            ctx.fill();
            
            // Weapon glow
            ctx.fillStyle = weapons[player.currentWeapon].color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = weapons[player.currentWeapon].color;
            ctx.fillRect(-2, -player.size - 5, 4, 8);
            
            // Engine glow
            if (keys['w'] || keys['s'] || keys['a'] || keys['d']) {
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffff00';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(-3 + i * 3, player.size + 8 + i * 2, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        function drawBackground() {
            // Screen shake effect
            if (screenShake > 0 && gameSettings.screenShakeEnabled) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * screenShake,
                    (Math.random() - 0.5) * screenShake
                );
                screenShake--;
            } else if (screenShake > 0) {
                screenShake = 0; // Disable shake if setting is off
            }
            
            // Enhanced animated grid
            ctx.strokeStyle = bulletTime ? '#008888' : '#003366';
            ctx.lineWidth = 1;
            const gridSize = 40;
            const offset = (Date.now() * (bulletTime ? 0.02 : 0.08)) % gridSize;
            
            for (let x = -offset; x < canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offset; y < canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Bullet time effect
            if (bulletTime) {
                ctx.fillStyle = 'rgba(0, 100, 200, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            if (screenShake >= 0) {
                ctx.restore();
            }
        }
        
        function showNotification(text) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = text;
            document.getElementById('gameContainer').appendChild(notification);
            setTimeout(() => notification.remove(), 2500);
        }
        
        function showShop() {
            // Hide all other screens first
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('achievementScreen').style.display = 'none';
            document.getElementById('researchScreen').style.display = 'none';
            
            if (gameState === 'playing') {
                gameState = 'shop';
            }
            shopScreen.style.display = 'flex';
        }
        
        function closeShop() {
            shopScreen.style.display = 'none';
            if (gameState === 'shop') {
                gameState = 'playing';
            } else {
                // If not in game, return to start screen
                document.getElementById('startScreen').style.display = 'flex';
            }
        }
        
        function showAchievements() {
            // Hide all other screens first
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('shop').style.display = 'none';
            document.getElementById('researchScreen').style.display = 'none';
            
            const allAchievements = document.getElementById('allAchievements');
            allAchievements.innerHTML = '';
            
            Object.keys(achievements).forEach(key => {
                const achievement = achievements[key];
                const div = document.createElement('div');
                div.className = achievement.unlocked ? 'shop-item unlocked' : 'shop-item';
                div.innerHTML = `
                    <h3 style="color: ${achievement.unlocked ? '#00ff00' : '#888'}; text-shadow: ${achievement.unlocked ? '0 0 10px #00ff00' : 'none'}">${achievement.name}</h3>
                    <p style="color: ${achievement.unlocked ? '#fff' : '#aaa'}">${achievement.description}</p>
                    <small style="color: ${achievement.unlocked ? '#00ff80' : '#666'}; font-weight: bold">${achievement.unlocked ? 'UNLOCKED' : 'LOCKED'}</small>
                `;
                allAchievements.appendChild(div);
            });
            
            achievementScreen.style.display = 'flex';
        }
        
        function closeAchievements() {
            achievementScreen.style.display = 'none';
            // Return to start screen if not in game
            if (gameState !== 'playing') {
                document.getElementById('startScreen').style.display = 'flex';
            }
        }
        
        function buyUpgrade(type) {
            let cost = 0;
            let canBuy = false;
            
            switch(type) {
                case 'health':
                    cost = 500 + (upgrades.health * 250);
                    if (credits >= cost && upgrades.health < 10) {
                        credits -= cost;
                        upgrades.health++;
                        player.maxHealth += 25;
                        player.health = Math.min(player.maxHealth, player.health + 25);
                        canBuy = true;
                        showNotification('Health Upgraded!');
                    }
                    break;
                case 'damage':
                    cost = 750 + (upgrades.damage * 500);
                    if (credits >= cost && upgrades.damage < 5) {
                        credits -= cost;
                        upgrades.damage++;
                        canBuy = true;
                        showNotification('Damage Upgraded!');
                    }
                    break;
                case 'speed':
                    cost = 600 + (upgrades.speed * 400);
                    if (credits >= cost && upgrades.speed < 5) {
                        credits -= cost;
                        upgrades.speed++;
                        canBuy = true;
                        showNotification('Speed Upgraded!');
                    }
                    break;
                case 'armor':
                    cost = 800 + ((upgrades.armor || 0) * 600);
                    if (credits >= cost && (upgrades.armor || 0) < 8) {
                        credits -= cost;
                        upgrades.armor = (upgrades.armor || 0) + 1;
                        canBuy = true;
                        showNotification('Armor Upgraded!');
                    }
                    break;
                case 'criticalChance':
                    cost = 900 + ((upgrades.criticalChance || 0) * 700);
                    if (credits >= cost && (upgrades.criticalChance || 0) < 10) {
                        credits -= cost;
                        upgrades.criticalChance = (upgrades.criticalChance || 0) + 1;
                        player.criticalChance += 0.05;
                        canBuy = true;
                        showNotification('Critical Strike Upgraded!');
                    }
                    break;
                case 'energyEfficiency':
                    cost = 700 + ((upgrades.energyEfficiency || 0) * 500);
                    if (credits >= cost && (upgrades.energyEfficiency || 0) < 5) {
                        credits -= cost;
                        upgrades.energyEfficiency = (upgrades.energyEfficiency || 0) + 1;
                        player.energyRegen += 0.5;
                        canBuy = true;
                        showNotification('Energy Efficiency Upgraded!');
                    }
                    break;
                case 'shieldCapacity':
                    cost = 1200 + ((upgrades.shieldCapacity || 0) * 800);
                    if (credits >= cost && (upgrades.shieldCapacity || 0) < 5) {
                        credits -= cost;
                        upgrades.shieldCapacity = (upgrades.shieldCapacity || 0) + 1;
                        player.maxShieldHealth += 50;
                        canBuy = true;
                        showNotification('Shield Capacity Upgraded!');
                    }
                    break;
                case 'magneticRadius':
                    cost = 800 + ((upgrades.magneticRadius || 0) * 600);
                    if (credits >= cost && (upgrades.magneticRadius || 0) < 3) {
                        credits -= cost;
                        upgrades.magneticRadius = (upgrades.magneticRadius || 0) + 1;
                        player.magneticRange += 30;
                        canBuy = true;
                        showNotification('Magnetic Collector Upgraded!');
                    }
                    break;
                case 'luck':
                    cost = 1500 + ((upgrades.luck || 0) * 1000);
                    if (credits >= cost && (upgrades.luck || 0) < 5) {
                        credits -= cost;
                        upgrades.luck = (upgrades.luck || 0) + 1;
                        player.luck += 0.15;
                        canBuy = true;
                        showNotification('Quantum Luck Field Upgraded!');
                    }
                    break;
                case 'regen':
                    cost = 1200 + ((upgrades.regen || 0) * 800);
                    if (credits >= cost && (upgrades.regen || 0) < 3) {
                        credits -= cost;
                        upgrades.regen = (upgrades.regen || 0) + 1;
                        canBuy = true;
                        showNotification('Regeneration Upgraded!');
                    }
                    break;
                case 'laser':
                    cost = 1500;
                    if (credits >= cost && !upgrades.weapons.includes('laser')) {
                        credits -= cost;
                        upgrades.weapons.push('laser');
                        canBuy = true;
                        showNotification('Laser Cannon Unlocked!');
                    }
                    break;
                case 'rocket':
                    cost = 2000;
                    if (credits >= cost && !upgrades.weapons.includes('rocket')) {
                        credits -= cost;
                        upgrades.weapons.push('rocket');
                        canBuy = true;
                        showNotification('Rocket Launcher Unlocked!');
                    }
                    break;
            }
            
            if (!canBuy) {
                showNotification('Cannot afford or maxed out!');
            }
            
            // Check all weapons achievement
            if (upgrades.weapons.length >= Object.keys(weapons).length - 1) {
                checkAchievement('allWeapons');
            }
            
            updateHUD();
        }
        
        function pauseGame() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseMenu.style.display = 'flex';
            }
        }
        
        function resumeGame() {
            if (gameState === 'paused') {
                gameState = 'playing';
                pauseMenu.style.display = 'none';
                gameLoop();
            }
        }
        
        function restartGame() {
            // Reset everything
            player.health = player.maxHealth;
            player.ammo = weapons[player.currentWeapon].ammo;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            player.shield = false;
            player.invulnerable = false;
            score = 0;
            wave = 1;
            kills = 0;
            combo = 0;
            maxCombo = 0;
            experience = 0;
            level = 1;
            nextLevelXP = 100;
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            powerups = [];
            explosions = [];
            hazards = [];
            lasers = [];
            bulletTime = false;
            screenShake = 0;
            comboTimer = 0;
            
            // Reset abilities
            for (let ability in abilities) {
                abilities[ability].cooldown = 0;
            }
            
            gameOverScreen.style.display = 'none';
            pauseMenu.style.display = 'none';
            gameState = 'playing';
            spawnEnemies();
            gameLoop();
        }
        
        function goToMenu() {
            gameState = 'start';
            pauseMenu.style.display = 'none';
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex';
        }
        
        function goToMainMenu() {
            // Hide all screens
            document.getElementById('shop').style.display = 'none';
            document.getElementById('researchScreen').style.display = 'none';
            document.getElementById('achievementScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            pauseMenu.style.display = 'none';
            
            // Show main menu
            gameState = 'start';
            startScreen.style.display = 'flex';
        }
        
        // UI System Functions
        function toggleMenu() {
            const panel = document.getElementById('menuPanel');
            panel.classList.toggle('open');
            
            // Close menu when clicking outside
            if (panel.classList.contains('open')) {
                document.addEventListener('click', closeMenuOnOutsideClick);
            } else {
                document.removeEventListener('click', closeMenuOnOutsideClick);
            }
        }
        
        function closeMenuOnOutsideClick(event) {
            const menu = document.getElementById('menuPanel');
            const toggle = document.getElementById('menuToggle');
            
            if (!menu.contains(event.target) && !toggle.contains(event.target)) {
                menu.classList.remove('open');
                document.removeEventListener('click', closeMenuOnOutsideClick);
            }
        }
        
        function showSettings() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('menuPanel').classList.remove('open');
        }
        
        function closeSettings() {
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            applySettings();
        }
        
        function showControls() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controlsScreen').style.display = 'flex';
            document.getElementById('menuPanel').classList.remove('open');
        }
        
        function closeControls() {
            document.getElementById('controlsScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        function switchSettingsTab(tabName) {
            // Remove active class from all tabs and sections
            document.querySelectorAll('.settings-tabs .tab-btn').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.settings-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Add active class to clicked tab and corresponding section
            event.target.classList.add('active');
            document.getElementById(tabName + 'Settings').classList.add('active');
        }
        
        function switchControlsTab(tabName) {
            // Remove active class from all tabs and sections
            document.querySelectorAll('.controls-tabs .tab-btn').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.controls-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Add active class to clicked tab and corresponding section
            event.target.classList.add('active');
            document.getElementById(tabName + 'Controls').classList.add('active');
        }
        
        // Global settings object to store current values
        let gameSettings = {
            highContrast: false,
            reducedMotion: false,
            colorblind: false,
            fontSize: 100,
            masterVolume: 50,
            sfxVolume: 75,
            musicVolume: 50,
            quality: 'medium',
            particles: true,
            screenShakeEnabled: true,
            bloom: true,
            autoSave: true,
            vibration: true
        };
        
        function applySettings() {
            // Get all settings from form elements
            const highContrast = document.getElementById('highContrastToggle').checked;
            const reducedMotion = document.getElementById('reducedMotionToggle').checked;
            const colorblind = document.getElementById('colorblindToggle').checked;
            const fontSize = document.getElementById('fontSizeSlider').value;
            const masterVolume = document.getElementById('volumeSlider').value;
            const sfxVolume = document.getElementById('sfxVolumeSlider').value;
            const musicVolume = document.getElementById('musicVolumeSlider').value;
            const quality = document.getElementById('qualitySelect').value;
            const particles = document.getElementById('particlesToggle').checked;
            const screenShakeEnabled = document.getElementById('screenShakeToggle').checked;
            const bloom = document.getElementById('bloomToggle').checked;
            const autoSave = document.getElementById('autoSaveToggle').checked;
            const vibration = document.getElementById('vibrationToggle').checked;
            
            // Update global settings
            gameSettings = {
                highContrast,
                reducedMotion,
                colorblind,
                fontSize: parseInt(fontSize),
                masterVolume: parseInt(masterVolume),
                sfxVolume: parseInt(sfxVolume),
                musicVolume: parseInt(musicVolume),
                quality,
                particles,
                screenShakeEnabled,
                bloom,
                autoSave,
                vibration
            };
            
            // Apply visual changes
            document.body.classList.toggle('high-contrast', highContrast);
            document.body.classList.toggle('reduced-motion', reducedMotion);
            document.body.classList.toggle('colorblind-friendly', colorblind);
            document.body.style.fontSize = fontSize + '%';
            
            // Apply CSS variables for custom styling
            document.documentElement.style.setProperty('--master-volume', masterVolume / 100);
            document.documentElement.style.setProperty('--sfx-volume', sfxVolume / 100);
            document.documentElement.style.setProperty('--music-volume', musicVolume / 100);
            
            // Graphics quality adjustments
            switch(quality) {
                case 'low':
                    document.documentElement.style.setProperty('--shadow-blur', '5px');
                    document.documentElement.style.setProperty('--glow-intensity', '0.5');
                    break;
                case 'medium':
                    document.documentElement.style.setProperty('--shadow-blur', '10px');
                    document.documentElement.style.setProperty('--glow-intensity', '1');
                    break;
                case 'high':
                    document.documentElement.style.setProperty('--shadow-blur', '15px');
                    document.documentElement.style.setProperty('--glow-intensity', '1.5');
                    break;
                case 'ultra':
                    document.documentElement.style.setProperty('--shadow-blur', '20px');
                    document.documentElement.style.setProperty('--glow-intensity', '2');
                    break;
            }
            
            // Store settings in localStorage
            localStorage.setItem('neonDystopiaSettings', JSON.stringify(gameSettings));
            
            showNotification('Settings applied successfully!');
        }
        
        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem('neonDystopiaSettings') || '{}');
            
            // Apply stored settings
            if (settings.highContrast) document.getElementById('highContrastToggle').checked = true;
            if (settings.reducedMotion) document.getElementById('reducedMotionToggle').checked = true;
            if (settings.colorblind) document.getElementById('colorblindToggle').checked = true;
            if (settings.fontSize) document.getElementById('fontSizeSlider').value = settings.fontSize;
            if (settings.masterVolume !== undefined) document.getElementById('volumeSlider').value = settings.masterVolume * 100;
            if (settings.sfxVolume !== undefined) document.getElementById('sfxVolumeSlider').value = settings.sfxVolume * 100;
            if (settings.musicVolume !== undefined) document.getElementById('musicVolumeSlider').value = settings.musicVolume * 100;
            if (settings.quality) document.getElementById('qualitySelect').value = settings.quality;
            if (settings.particles !== undefined) document.getElementById('particlesToggle').checked = settings.particles;
            if (settings.screenShake !== undefined) document.getElementById('screenShakeToggle').checked = settings.screenShake;
            if (settings.bloom !== undefined) document.getElementById('bloomToggle').checked = settings.bloom;
            
            applySettings();
        }
        
        function resetSettings() {
            // Reset all settings to default
            document.getElementById('highContrastToggle').checked = false;
            document.getElementById('reducedMotionToggle').checked = false;
            document.getElementById('colorblindToggle').checked = false;
            document.getElementById('fontSizeSlider').value = 100;
            document.getElementById('volumeSlider').value = 50;
            document.getElementById('sfxVolumeSlider').value = 75;
            document.getElementById('musicVolumeSlider').value = 50;
            document.getElementById('qualitySelect').value = 'medium';
            document.getElementById('particlesToggle').checked = true;
            document.getElementById('screenShakeToggle').checked = true;
            document.getElementById('bloomToggle').checked = true;
            
            applySettings();
            showNotification('Settings reset to default');
        }
        
        function resetControls() {
            showNotification('Controls reset to default');
        }
        
        // Keyboard Navigation
        let focusedElement = null;
        let focusableElements = [];
        
        function initKeyboardNavigation() {
            updateFocusableElements();
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    navigateWithTab(e.shiftKey);
                } else if (e.key === 'Enter' || e.key === ' ') {
                    if (focusedElement && (focusedElement.tagName === 'BUTTON' || focusedElement.type === 'checkbox')) {
                        e.preventDefault();
                        focusedElement.click();
                    }
                } else if (e.key === 'Escape') {
                    // Close any open modals
                    if (document.getElementById('settingsScreen').style.display === 'flex') {
                        closeSettings();
                    } else if (document.getElementById('controlsScreen').style.display === 'flex') {
                        closeControls();
                    } else if (document.getElementById('menuPanel').classList.contains('open')) {
                        document.getElementById('menuPanel').classList.remove('open');
                    }
                }
            });
        }
        
        function updateFocusableElements() {
            const visibleScreens = Array.from(document.querySelectorAll('.modal-screen, #startScreen'))
                .filter(screen => screen.style.display !== 'none');
            
            if (visibleScreens.length > 0) {
                const activeScreen = visibleScreens[visibleScreens.length - 1];
                focusableElements = Array.from(activeScreen.querySelectorAll(
                    'button, input, select, textarea, [tabindex]:not([tabindex="-1"])'
                )).filter(el => !el.disabled && el.offsetParent !== null);
            }
        }
        
        function navigateWithTab(reverse = false) {
            updateFocusableElements();
            
            if (focusableElements.length === 0) return;
            
            let currentIndex = focusableElements.indexOf(focusedElement);
            
            if (reverse) {
                currentIndex = currentIndex <= 0 ? focusableElements.length - 1 : currentIndex - 1;
            } else {
                currentIndex = currentIndex >= focusableElements.length - 1 ? 0 : currentIndex + 1;
            }
            
            focusedElement = focusableElements[currentIndex];
            focusedElement.focus();
        }
        
        // Slider Value Updates
        function updateSliderValues() {
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                document.getElementById('volumeValue').textContent = e.target.value + '%';
            });
            
            document.getElementById('sfxVolumeSlider').addEventListener('input', (e) => {
                document.getElementById('sfxVolumeValue').textContent = e.target.value + '%';
            });
            
            document.getElementById('musicVolumeSlider').addEventListener('input', (e) => {
                document.getElementById('musicVolumeValue').textContent = e.target.value + '%';
            });
            
            document.getElementById('fontSizeSlider').addEventListener('input', (e) => {
                document.getElementById('fontSizeValue').textContent = e.target.value + '%';
            });
        }
        
        function saveGameData() {
            const saveData = {
                upgrades,
                achievements,
                gameStats,
                researchTree,
                totalPlayTime,
                sessionsPlayed,
                highestWave: Math.max(wave, gameStats.highestWave),
                totalKills: kills + (parseInt(localStorage.getItem('totalKills')) || 0)
            };
            
            localStorage.setItem('neonDystopiaData', JSON.stringify(saveData));
        }
        
        function loadGameData() {
            const saveData = localStorage.getItem('neonDystopiaData');
            if (saveData) {
                const data = JSON.parse(saveData);
                Object.assign(upgrades, data.upgrades || {});
                Object.assign(achievements, data.achievements || {});
                Object.assign(gameStats, data.gameStats || {});
                Object.assign(researchTree, data.researchTree || {});
                totalPlayTime = data.totalPlayTime || 0;
                sessionsPlayed = data.sessionsPlayed || 0;
                
                // Update display
                document.getElementById('sessionCount').textContent = sessionsPlayed;
                document.getElementById('bestWave').textContent = data.highestWave || 0;
                document.getElementById('totalKillsDisplay').textContent = data.totalKills || 0;
            }
        }
        
        // Enhanced Game Loop with all new systems
        function gameLoop() {
            if (gameState !== 'playing') return;
            
            // Update counters
            survivalTime++;
            totalPlayTime++;
            
            // Auto-save every 30 seconds
            if (totalPlayTime % 1800 === 0) {
                saveGameData();
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update difficulty
            updateDifficulty();
            
            // Update bullet time
            if (bulletTime) {
                bulletTimeTimer--;
                if (bulletTimeTimer <= 0) {
                    bulletTime = false;
                }
            }
            
            // Update ability cooldowns
            for (let ability in abilities) {
                if (abilities[ability].cooldown > 0) {
                    abilities[ability].cooldown -= 16.67;
                }
            }
            
            // Update player status effects
            player.statusEffects = player.statusEffects.filter(effect => {
                effect.duration--;
                return effect.duration > 0;
            });
            
            // Update energy regeneration
            if (player.energy < player.maxEnergy) {
                player.energyRegenTimer++;
                if (player.energyRegenTimer >= 30) {
                    player.energy = Math.min(player.maxEnergy, player.energy + player.energyRegen);
                    player.energyRegenTimer = 0;
                }
            }
            
            // Update weapon heat
            if (player.weaponHeat > 0) {
                player.weaponHeat = Math.max(0, player.weaponHeat - player.coolingRate);
            }
            
            // Update kill streak timer
            if (Date.now() - player.lastKillTime > 5000) {
                player.killStreak = 0;
            }
            
            // Draw background
            drawBackground();
            
            // Update
            updatePlayer();
            
            // Update missions
            updateMissions();
            
            // Update game objects
            bullets = bullets.filter(bullet => bullet.update());
            enemyBullets = enemyBullets.filter(bullet => bullet.update());
            enemies.forEach(enemy => enemy.update());
            particles = particles.filter(particle => particle.update());
            powerups = powerups.filter(powerup => powerup.update());
            explosions = explosions.filter(explosion => explosion.update());
            hazards = hazards.filter(hazard => hazard.update());
            lasers = lasers.filter(laser => laser.update());
            barriers = barriers.filter(barrier => barrier.update());
            drones = drones.filter(drone => drone.update());
            meteors = meteors.filter(meteor => meteor.update());
            wormholes = wormholes.filter(wormhole => wormhole.update());
            specialEvents = specialEvents.filter(event => event.update());
            
            // Enhanced environmental spawning
            if (Math.random() < environmentHazardLevel * 0.001) {
                spawnRandomHazard();
            }
            
            // Dynamic powerup spawning based on player performance
            if (Math.random() < 0.002 + (player.killStreak * 0.0001)) {
                spawnRandomPowerup();
            }
            
            // Check achievements
            if (drones.length >= 3) checkAchievement('droneCommander');
            if (wave > gameStats.highestWave) gameStats.highestWave = wave;
            if (survivalTime > gameStats.longestSurvival) gameStats.longestSurvival = survivalTime;
            
            // Check collisions
            checkCollisions();
            
            // Spawn new wave
            if (enemies.length === 0) {
                // Check for perfect wave
                if (damageTakenThisWave === 0 && wave > 1) {
                    perfectWaves++;
                    perfectWaveStreak++;
                    checkAchievement('perfectWave');
                    showNotification('PERFECT WAVE! +50% XP Bonus');
                    experience += 50;
                } else {
                    perfectWaveStreak = 0;
                }
                
                wave++;
                damageTakenThisWave = 0;
                damageDealtThisWave = 0;
                
                spawnEnemies();
                showNotification(`Wave ${wave} - Difficulty: ${difficulty.toFixed(1)}x`);
                
                // Wave achievements
                if (wave === 5) checkAchievement('wave5');
                if (wave === 10) checkAchievement('wave10');
                
                updateHUD();
            }
            
            // Draw everything with enhanced effects
            barriers.forEach(barrier => barrier.draw());
            wormholes.forEach(wormhole => wormhole.draw());
            meteors.forEach(meteor => meteor.draw());
            lasers.forEach(laser => laser.draw());
            explosions.forEach(explosion => explosion.draw());
            bullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            enemies.forEach(enemy => enemy.draw());
            particles.forEach(particle => particle.draw());
            powerups.forEach(powerup => powerup.draw());
            hazards.forEach(hazard => hazard.draw());
            drones.forEach(drone => drone.draw());
            drawPlayer();
            
            // Draw UI overlays
            drawDamageNumbers();
            drawStatusEffects();
            
            updateHUD();
            updateMinimap();
            requestAnimationFrame(gameLoop);
        }
        
        function spawnRandomHazard() {
            const types = ['laser', 'mine', 'gravity_well', 'emp_field'];
            const type = types[Math.floor(Math.random() * types.length)];
            hazards.push(new Hazard(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                type
            ));
        }
        
        function spawnRandomPowerup() {
            const types = ['health', 'ammo', 'credits', 'shield', 'damage', 'energy', 'weapon_boost'];
            const type = types[Math.floor(Math.random() * types.length)];
            powerups.push(new Powerup(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                type
            ));
        }
        
        function drawDamageNumbers() {
            // Implementation for floating damage numbers
        }
        
        function drawStatusEffects() {
            // Implementation for status effect indicators
        }
        
        // Add all the new global functions
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.switchMissionTab = (tab) => {
            document.querySelectorAll('#missionScreen .tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#missionScreen > div[id$="Missions"]').forEach(d => d.style.display = 'none');
            event.target.classList.add('active');
            document.getElementById(tab + 'Missions').style.display = 'block';
        };
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === 'r' || e.key === 'R') reload();
            if (e.key === ' ') {
                e.preventDefault();
                if (gameState === 'playing') showShop();
            }
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                if (gameState === 'playing') pauseGame();
                else if (gameState === 'paused') resumeGame();
            }
            if (e.key === 'm' || e.key === 'M') {
                isMuted = !isMuted;
                showNotification(isMuted ? 'Audio Muted' : 'Audio Enabled');
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                weaponWheel.style.display = weaponWheel.style.display === 'block' ? 'none' : 'block';
            }
            if (e.key === 'q' || e.key === 'Q') useAbility('shield');
            if (e.key === 'e' || e.key === 'E') useAbility('dash');
            if (e.key === 'f' || e.key === 'F') useAbility('bomb');
            if (e.key === 't' || e.key === 'T') useAbility('time');
            if (e.key === 'g' || e.key === 'G') useAbility('heal');
            if (['1', '2', '3', '4', '5', '6'].includes(e.key)) switchWeapon(e.key);
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === 'Tab') {
                weaponWheel.style.display = 'none';
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (gameState === 'playing') {
                mouse.down = true;
                shoot();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            mouse.down = false;
        });
        
        // Auto-fire when holding mouse
        setInterval(() => {
            if (mouse.down && gameState === 'playing') {
                shoot();
            }
        }, 50);
        
        // Weapon wheel handlers
        document.querySelectorAll('.weapon-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                const weapon = slot.dataset.weapon;
                if (upgrades.weapons.includes(weapon)) {
                    player.currentWeapon = weapon;
                    player.ammo = weapons[weapon].ammo;
                    updateHUD();
                    showNotification(`Weapon: ${weapons[weapon].name}`);
                }
                weaponWheel.style.display = 'none';
            });
        });
        
        // Button handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            initAudio();
            startScreen.style.display = 'none';
            gameState = 'playing';
            spawnEnemies();
            gameLoop();
        });
        
        document.getElementById('shopBtn').addEventListener('click', () => {
            startScreen.style.display = 'none';
            showShop();
        });
        
        document.getElementById('achievementsBtn').addEventListener('click', () => {
            startScreen.style.display = 'none';
            showAchievements();
        });
        
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        
        // Enhanced Window Management
        function switchShopTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.shop-category').forEach(c => c.style.display = 'none');
            
            event.target.classList.add('active');
            document.getElementById(tab + 'Tab').style.display = 'block';
            
            if (tab === 'weapons') {
                updateWeaponShop();
            }
        }
        
        function updateWeaponShop() {
            const container = document.getElementById('weaponShopItems');
            container.innerHTML = '';
            
            Object.entries(weapons).forEach(([key, weapon]) => {
                if (key === 'blaster') return; // Skip default weapon
                
                const isOwned = upgrades.weapons.includes(key);
                const canAfford = credits >= weapon.unlockCost;
                
                const item = document.createElement('div');
                item.className = isOwned ? 'shop-item' : (canAfford ? 'shop-item' : 'shop-item unavailable');
                item.innerHTML = `
                    <h3>${weapon.name}</h3>
                    <p>${weapon.description}</p>
                    <p>Damage: ${weapon.damage} | Ammo: ${weapon.ammo} | Range: ${weapon.range}</p>
                    <p>${isOwned ? 'OWNED' : `Cost: ${weapon.unlockCost} Credits`}</p>
                `;
                
                if (!isOwned && canAfford) {
                    item.onclick = () => buyWeapon(key);
                }
                
                container.appendChild(item);
            });
        }
        
        function buyWeapon(weaponKey) {
            const weapon = weapons[weaponKey];
            if (credits >= weapon.unlockCost && !upgrades.weapons.includes(weaponKey)) {
                credits -= weapon.unlockCost;
                upgrades.weapons.push(weaponKey);
                showNotification(`${weapon.name} Unlocked!`);
                updateWeaponShop();
                updateHUD();
            }
        }
        
        function showResearch() {
            // Hide all other screens first
            document.getElementById('shop').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('achievementScreen').style.display = 'none';
            
            document.getElementById('researchScreen').style.display = 'flex';
            updateResearchScreen();
        }
        
        function closeResearch() {
            document.getElementById('researchScreen').style.display = 'none';
            
            // Return to shop if it was open, otherwise to start screen
            if (gameState === 'shop' || gameState === 'playing') {
                document.getElementById('shop').style.display = 'flex';
            } else {
                document.getElementById('startScreen').style.display = 'flex';
            }
        }
        
        function updateResearchScreen() {
            const container = document.getElementById('researchNodes');
            container.innerHTML = '';
            
            Object.entries(researchTree).forEach(([key, research]) => {
                const node = document.createElement('div');
                node.className = research.unlocked ? 'research-node' : 'research-node locked';
                
                const progress = research.level / research.maxLevel * 100;
                const cost = research.cost * (research.level + 1);
                const canAfford = credits >= cost && research.level < research.maxLevel;
                
                node.innerHTML = `
                    <h3>${key.toUpperCase()}</h3>
                    <p>Level ${research.level}/${research.maxLevel}</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progress}%"></div>
                    </div>
                    <p>Cost: ${cost} Credits</p>
                    <small>${getResearchDescription(key, research.level)}</small>
                `;
                
                if (research.unlocked && canAfford) {
                    node.onclick = () => buyResearch(key);
                }
                
                container.appendChild(node);
            });
        }
        
        function getResearchDescription(key, level) {
            const descriptions = {
                weaponTech: 'Unlocks advanced weapons and improves weapon efficiency',
                defensiveTech: 'Enhances shields, armor, and defensive capabilities',
                economicTech: 'Improves credit and resource generation',
                advancedAI: 'Upgrades targeting systems and tactical awareness',
                nanobioTech: 'Enhances regeneration and biological augmentation',
                quantumTech: 'Unlocks experimental quantum technologies'
            };
            return descriptions[key] || 'Advanced research node';
        }
        
        function buyResearch(key) {
            const research = researchTree[key];
            const cost = research.cost * (research.level + 1);
            
            if (credits >= cost && research.level < research.maxLevel) {
                credits -= cost;
                research.level++;
                applyResearchBonus(key, research.level);
                showNotification(`${key} Research Upgraded!`);
                updateResearchScreen();
                updateHUD();
                
                // Unlock new research paths
                if (research.level === research.maxLevel) {
                    unlockNewResearch(key);
                }
            }
        }
        
        function applyResearchBonus(key, level) {
            switch(key) {
                case 'weaponTech':
                    upgrades.fireRate += 0.1;
                    upgrades.penetration += 0.2;
                    break;
                case 'defensiveTech':
                    upgrades.armor += 0.05;
                    upgrades.shieldCapacity += 25;
                    break;
                case 'economicTech':
                    upgrades.creditBonus += 0.15;
                    upgrades.experienceBonus += 0.1;
                    break;
                case 'advancedAI':
                    upgrades.criticalChance += 0.02;
                    player.accuracy += 0.05;
                    break;
                case 'nanobioTech':
                    upgrades.regen += 1;
                    player.maxHealth += 15;
                    break;
                case 'quantumTech':
                    player.ricochetCount += 1;
                    upgrades.luck += 0.1;
                    break;
            }
        }
        
        function showMissions() {
            // Hide other screens first
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('menuPanel').classList.remove('open');
            
            document.getElementById('missionScreen').style.display = 'flex';
            updateMissionScreen();
        }
        
        function closeMissions() {
            document.getElementById('missionScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        function updateMissionScreen() {
            // Update active missions
            const activeContainer = document.getElementById('activeMissions');
            activeContainer.innerHTML = '';
            activeMissions.forEach(mission => {
                const item = document.createElement('div');
                item.className = 'mission-item';
                item.innerHTML = `
                    <h3>${mission.name}</h3>
                    <p>${mission.description}</p>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${(mission.progress / mission.target) * 100}%"></div>
                    </div>
                    <p>Progress: ${mission.progress}/${mission.target}</p>
                    <p>Reward: ${mission.reward} Credits</p>
                `;
                activeContainer.appendChild(item);
            });
        }
        
        function showStatistics() {
            // Hide other screens first
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('menuPanel').classList.remove('open');
            
            document.getElementById('statisticsScreen').style.display = 'flex';
            updateStatisticsScreen();
        }
        
        function closeStatistics() {
            document.getElementById('statisticsScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        function updateStatisticsScreen() {
            const container = document.getElementById('statsContainer');
            container.innerHTML = '';
            
            const stats = [
                { name: 'Total Score', value: score },
                { name: 'Highest Wave', value: gameStats.highestWave },
                { name: 'Total Kills', value: kills },
                { name: 'Longest Survival', value: Math.floor(gameStats.longestSurvival / 60) + ' min' },
                { name: 'Accuracy', value: Math.round((gameStats.shotsHit / Math.max(gameStats.totalShots, 1)) * 100) + '%' },
                { name: 'Total Damage Dealt', value: Math.floor(gameStats.totalDamageDealt) },
                { name: 'Total Damage Taken', value: Math.floor(gameStats.totalDamageTaken) },
                { name: 'Powerups Collected', value: gameStats.powerupsCollected },
                { name: 'Abilities Used', value: gameStats.abilitiesUsed },
                { name: 'Perfect Waves', value: perfectWaves },
                { name: 'Max Combo', value: maxCombo },
                { name: 'Bosses Defeated', value: bossesKilled }
            ];
            
            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <h3>${stat.name}</h3>
                    <div style="font-size: 2em; color: #00ffff; text-shadow: 0 0 10px #00ffff;">
                        ${stat.value}
                    </div>
                `;
                container.appendChild(card);
            });
        }
        
        // Enhanced buy functions
        function buyConsumable(type) {
            const costs = {
                healthPack: 100,
                energyBooster: 150,
                damageBooster: 200
            };
            
            if (credits >= costs[type]) {
                credits -= costs[type];
                player.consumables = player.consumables || {};
                player.consumables[type] = (player.consumables[type] || 0) + 1;
                showNotification(`${type} purchased!`);
                updateHUD();
            }
        }
        
        // Global functions
        window.buyUpgrade = buyUpgrade;
        window.buyWeapon = buyWeapon;
        window.buyConsumable = buyConsumable;
        window.buyResearch = buyResearch;
        window.switchShopTab = switchShopTab;
        window.switchMissionTab = switchMissionTab;
        window.closeShop = closeShop;
        window.showShop = showShop;
        window.showResearch = showResearch;
        window.closeResearch = closeResearch;
        window.showMissions = showMissions;
        window.closeMissions = closeMissions;
        window.showStatistics = showStatistics;
        window.closeStatistics = closeStatistics;
        window.showAchievements = showAchievements;
        window.closeAchievements = closeAchievements;
        window.resumeGame = resumeGame;
        window.restartGame = restartGame;
        window.goToMenu = goToMenu;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.goToMainMenu = goToMainMenu;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.goToMainMenu = goToMainMenu;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.goToMainMenu = goToMainMenu;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        window.showSettings = showSettings;
        window.closeSettings = closeSettings;
        window.showControls = showControls;
        window.closeControls = closeControls;
        window.switchSettingsTab = switchSettingsTab;
        window.switchControlsTab = switchControlsTab;
        window.resetSettings = resetSettings;
        window.resetControls = resetControls;
        
        // Initialize
        loadGameData();
        loadSettings();
        sessionsPlayed++;
        
        // Initialize UI systems
        initKeyboardNavigation();
        updateSliderValues();
        
        // Menu toggle event listener
        document.getElementById('menuToggle').addEventListener('click', toggleMenu);
        
        // Initialize active missions
        activeMissions = generateMissions().slice(0, 3);
        activeMissions.forEach(mission => mission.active = true);
        
        player.maxHealth = 100 + upgrades.health * 25;
        player.health = player.maxHealth;
        player.maxEnergy = 100 + upgrades.energyEfficiency * 20;
        player.energy = player.maxEnergy;
        player.maxShieldHealth = upgrades.shieldCapacity * 50;
        player.shieldHealth = player.maxShieldHealth;
        
        // Initialize weapon kill tracking
        Object.keys(weapons).forEach(weapon => {
            weaponKills[weapon] = 0;
        });
        
        updateHUD();
    </script>
</body>
</html>